
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Designation
 * 
 */
export type Designation = $Result.DefaultSelection<Prisma.$DesignationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model CompanyProfile
 * 
 */
export type CompanyProfile = $Result.DefaultSelection<Prisma.$CompanyProfilePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model EmployeeShift
 * 
 */
export type EmployeeShift = $Result.DefaultSelection<Prisma.$EmployeeShiftPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model LeaveType
 * 
 */
export type LeaveType = $Result.DefaultSelection<Prisma.$LeaveTypePayload>
/**
 * Model LeaveEntry
 * 
 */
export type LeaveEntry = $Result.DefaultSelection<Prisma.$LeaveEntryPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model DeviceUser
 * 
 */
export type DeviceUser = $Result.DefaultSelection<Prisma.$DeviceUserPayload>
/**
 * Model RawDeviceLog
 * 
 */
export type RawDeviceLog = $Result.DefaultSelection<Prisma.$RawDeviceLogPayload>
/**
 * Model AttendanceLog
 * 
 */
export type AttendanceLog = $Result.DefaultSelection<Prisma.$AttendanceLogPayload>
/**
 * Model SyncStatus
 * 
 */
export type SyncStatus = $Result.DefaultSelection<Prisma.$SyncStatusPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.designation`: Exposes CRUD operations for the **Designation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designations
    * const designations = await prisma.designation.findMany()
    * ```
    */
  get designation(): Prisma.DesignationDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.companyProfile`: Exposes CRUD operations for the **CompanyProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyProfiles
    * const companyProfiles = await prisma.companyProfile.findMany()
    * ```
    */
  get companyProfile(): Prisma.CompanyProfileDelegate<ExtArgs>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs>;

  /**
   * `prisma.employeeShift`: Exposes CRUD operations for the **EmployeeShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeShifts
    * const employeeShifts = await prisma.employeeShift.findMany()
    * ```
    */
  get employeeShift(): Prisma.EmployeeShiftDelegate<ExtArgs>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs>;

  /**
   * `prisma.leaveType`: Exposes CRUD operations for the **LeaveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveTypes
    * const leaveTypes = await prisma.leaveType.findMany()
    * ```
    */
  get leaveType(): Prisma.LeaveTypeDelegate<ExtArgs>;

  /**
   * `prisma.leaveEntry`: Exposes CRUD operations for the **LeaveEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveEntries
    * const leaveEntries = await prisma.leaveEntry.findMany()
    * ```
    */
  get leaveEntry(): Prisma.LeaveEntryDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.deviceUser`: Exposes CRUD operations for the **DeviceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceUsers
    * const deviceUsers = await prisma.deviceUser.findMany()
    * ```
    */
  get deviceUser(): Prisma.DeviceUserDelegate<ExtArgs>;

  /**
   * `prisma.rawDeviceLog`: Exposes CRUD operations for the **RawDeviceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawDeviceLogs
    * const rawDeviceLogs = await prisma.rawDeviceLog.findMany()
    * ```
    */
  get rawDeviceLog(): Prisma.RawDeviceLogDelegate<ExtArgs>;

  /**
   * `prisma.attendanceLog`: Exposes CRUD operations for the **AttendanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceLogs
    * const attendanceLogs = await prisma.attendanceLog.findMany()
    * ```
    */
  get attendanceLog(): Prisma.AttendanceLogDelegate<ExtArgs>;

  /**
   * `prisma.syncStatus`: Exposes CRUD operations for the **SyncStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncStatuses
    * const syncStatuses = await prisma.syncStatus.findMany()
    * ```
    */
  get syncStatus(): Prisma.SyncStatusDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Location: 'Location',
    Branch: 'Branch',
    Department: 'Department',
    Designation: 'Designation',
    Category: 'Category',
    Employee: 'Employee',
    CompanyProfile: 'CompanyProfile',
    Shift: 'Shift',
    EmployeeShift: 'EmployeeShift',
    Holiday: 'Holiday',
    LeaveType: 'LeaveType',
    LeaveEntry: 'LeaveEntry',
    Device: 'Device',
    DeviceUser: 'DeviceUser',
    RawDeviceLog: 'RawDeviceLog',
    AttendanceLog: 'AttendanceLog',
    SyncStatus: 'SyncStatus',
    AuditLog: 'AuditLog',
    Payroll: 'Payroll'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "location" | "branch" | "department" | "designation" | "category" | "employee" | "companyProfile" | "shift" | "employeeShift" | "holiday" | "leaveType" | "leaveEntry" | "device" | "deviceUser" | "rawDeviceLog" | "attendanceLog" | "syncStatus" | "auditLog" | "payroll"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Designation: {
        payload: Prisma.$DesignationPayload<ExtArgs>
        fields: Prisma.DesignationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findFirst: {
            args: Prisma.DesignationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findMany: {
            args: Prisma.DesignationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          create: {
            args: Prisma.DesignationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          createMany: {
            args: Prisma.DesignationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          delete: {
            args: Prisma.DesignationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          update: {
            args: Prisma.DesignationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          deleteMany: {
            args: Prisma.DesignationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DesignationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          aggregate: {
            args: Prisma.DesignationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignation>
          }
          groupBy: {
            args: Prisma.DesignationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignationCountArgs<ExtArgs>
            result: $Utils.Optional<DesignationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      CompanyProfile: {
        payload: Prisma.$CompanyProfilePayload<ExtArgs>
        fields: Prisma.CompanyProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findFirst: {
            args: Prisma.CompanyProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findMany: {
            args: Prisma.CompanyProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          create: {
            args: Prisma.CompanyProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          createMany: {
            args: Prisma.CompanyProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          delete: {
            args: Prisma.CompanyProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          update: {
            args: Prisma.CompanyProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          deleteMany: {
            args: Prisma.CompanyProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          aggregate: {
            args: Prisma.CompanyProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyProfile>
          }
          groupBy: {
            args: Prisma.CompanyProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      EmployeeShift: {
        payload: Prisma.$EmployeeShiftPayload<ExtArgs>
        fields: Prisma.EmployeeShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findFirst: {
            args: Prisma.EmployeeShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findMany: {
            args: Prisma.EmployeeShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>[]
          }
          create: {
            args: Prisma.EmployeeShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          createMany: {
            args: Prisma.EmployeeShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>[]
          }
          delete: {
            args: Prisma.EmployeeShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          update: {
            args: Prisma.EmployeeShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          aggregate: {
            args: Prisma.EmployeeShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeShift>
          }
          groupBy: {
            args: Prisma.EmployeeShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeShiftCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeShiftCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      LeaveType: {
        payload: Prisma.$LeaveTypePayload<ExtArgs>
        fields: Prisma.LeaveTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findFirst: {
            args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findMany: {
            args: Prisma.LeaveTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          create: {
            args: Prisma.LeaveTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          createMany: {
            args: Prisma.LeaveTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          delete: {
            args: Prisma.LeaveTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          update: {
            args: Prisma.LeaveTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          aggregate: {
            args: Prisma.LeaveTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveType>
          }
          groupBy: {
            args: Prisma.LeaveTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveTypeCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeCountAggregateOutputType> | number
          }
        }
      }
      LeaveEntry: {
        payload: Prisma.$LeaveEntryPayload<ExtArgs>
        fields: Prisma.LeaveEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaveEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          findMany: {
            args: Prisma.LeaveEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>[]
          }
          create: {
            args: Prisma.LeaveEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          createMany: {
            args: Prisma.LeaveEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>[]
          }
          delete: {
            args: Prisma.LeaveEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          update: {
            args: Prisma.LeaveEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaveEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaveEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveEntry>
          }
          groupBy: {
            args: Prisma.LeaveEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveEntryCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceUser: {
        payload: Prisma.$DeviceUserPayload<ExtArgs>
        fields: Prisma.DeviceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          findFirst: {
            args: Prisma.DeviceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          findMany: {
            args: Prisma.DeviceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>[]
          }
          create: {
            args: Prisma.DeviceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          createMany: {
            args: Prisma.DeviceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>[]
          }
          delete: {
            args: Prisma.DeviceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          update: {
            args: Prisma.DeviceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          deleteMany: {
            args: Prisma.DeviceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceUserPayload>
          }
          aggregate: {
            args: Prisma.DeviceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceUser>
          }
          groupBy: {
            args: Prisma.DeviceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceUserCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceUserCountAggregateOutputType> | number
          }
        }
      }
      RawDeviceLog: {
        payload: Prisma.$RawDeviceLogPayload<ExtArgs>
        fields: Prisma.RawDeviceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawDeviceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawDeviceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          findFirst: {
            args: Prisma.RawDeviceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawDeviceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          findMany: {
            args: Prisma.RawDeviceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>[]
          }
          create: {
            args: Prisma.RawDeviceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          createMany: {
            args: Prisma.RawDeviceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawDeviceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>[]
          }
          delete: {
            args: Prisma.RawDeviceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          update: {
            args: Prisma.RawDeviceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          deleteMany: {
            args: Prisma.RawDeviceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawDeviceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RawDeviceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawDeviceLogPayload>
          }
          aggregate: {
            args: Prisma.RawDeviceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawDeviceLog>
          }
          groupBy: {
            args: Prisma.RawDeviceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawDeviceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawDeviceLogCountArgs<ExtArgs>
            result: $Utils.Optional<RawDeviceLogCountAggregateOutputType> | number
          }
        }
      }
      AttendanceLog: {
        payload: Prisma.$AttendanceLogPayload<ExtArgs>
        fields: Prisma.AttendanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findFirst: {
            args: Prisma.AttendanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findMany: {
            args: Prisma.AttendanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          create: {
            args: Prisma.AttendanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          createMany: {
            args: Prisma.AttendanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          delete: {
            args: Prisma.AttendanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          update: {
            args: Prisma.AttendanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          aggregate: {
            args: Prisma.AttendanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceLog>
          }
          groupBy: {
            args: Prisma.AttendanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogCountAggregateOutputType> | number
          }
        }
      }
      SyncStatus: {
        payload: Prisma.$SyncStatusPayload<ExtArgs>
        fields: Prisma.SyncStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findFirst: {
            args: Prisma.SyncStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findMany: {
            args: Prisma.SyncStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          create: {
            args: Prisma.SyncStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          createMany: {
            args: Prisma.SyncStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          delete: {
            args: Prisma.SyncStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          update: {
            args: Prisma.SyncStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          deleteMany: {
            args: Prisma.SyncStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          aggregate: {
            args: Prisma.SyncStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncStatus>
          }
          groupBy: {
            args: Prisma.SyncStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    branches: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | LocationCountOutputTypeCountBranchesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    employees: number
    departments: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | BranchCountOutputTypeCountEmployeesArgs
    departments?: boolean | BranchCountOutputTypeCountDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    employees: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type DesignationCountOutputType
   */

  export type DesignationCountOutputType = {
    employees: number
  }

  export type DesignationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DesignationCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DesignationCountOutputType without action
   */
  export type DesignationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignationCountOutputType
     */
    select?: DesignationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DesignationCountOutputType without action
   */
  export type DesignationCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    employees: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | CategoryCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    managedDepartments: number
    managerApprovedLeaves: number
    ceoApprovedLeaves: number
    attendanceLogs: number
    leaveEntries: number
    employeeShifts: number
    payrolls: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    managedDepartments?: boolean | EmployeeCountOutputTypeCountManagedDepartmentsArgs
    managerApprovedLeaves?: boolean | EmployeeCountOutputTypeCountManagerApprovedLeavesArgs
    ceoApprovedLeaves?: boolean | EmployeeCountOutputTypeCountCeoApprovedLeavesArgs
    attendanceLogs?: boolean | EmployeeCountOutputTypeCountAttendanceLogsArgs
    leaveEntries?: boolean | EmployeeCountOutputTypeCountLeaveEntriesArgs
    employeeShifts?: boolean | EmployeeCountOutputTypeCountEmployeeShiftsArgs
    payrolls?: boolean | EmployeeCountOutputTypeCountPayrollsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountManagedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountManagerApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveEntryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountCeoApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveEntryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveEntryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    employees: number
    employeeShifts: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | ShiftCountOutputTypeCountEmployeesArgs
    employeeShifts?: boolean | ShiftCountOutputTypeCountEmployeeShiftsArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
  }


  /**
   * Count Type LeaveTypeCountOutputType
   */

  export type LeaveTypeCountOutputType = {
    leaveEntries: number
  }

  export type LeaveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveEntries?: boolean | LeaveTypeCountOutputTypeCountLeaveEntriesArgs
  }

  // Custom InputTypes
  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveTypeCountOutputType
     */
    select?: LeaveTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountLeaveEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveEntryWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    deviceUsers: number
    rawDeviceLogs: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceUsers?: boolean | DeviceCountOutputTypeCountDeviceUsersArgs
    rawDeviceLogs?: boolean | DeviceCountOutputTypeCountRawDeviceLogsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDeviceUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceUserWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountRawDeviceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawDeviceLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    role: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    role: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    role: string
    employeeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      role: string
      employeeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zipCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zipCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    country: number
    zipCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zipCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branches?: boolean | Location$branchesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | Location$branchesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      branches: Prisma.$BranchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      zipCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends Location$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Location$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly zipCode: FieldRef<"Location", 'String'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.branches
   */
  export type Location$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    locationId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    locationId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    code: number
    locationId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    name: string
    code: string
    locationId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Branch$locationArgs<ExtArgs>
    employees?: boolean | Branch$employeesArgs<ExtArgs>
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Branch$locationArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Branch$locationArgs<ExtArgs>
    employees?: boolean | Branch$employeesArgs<ExtArgs>
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Branch$locationArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      locationId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Branch$locationArgs<ExtArgs> = {}>(args?: Subset<T, Branch$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employees<T extends Branch$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    departments<T extends Branch$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly locationId: FieldRef<"Branch", 'String'>
    readonly isActive: FieldRef<"Branch", 'Boolean'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.location
   */
  export type Branch$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Branch.employees
   */
  export type Branch$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Branch.departments
   */
  export type Branch$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    branchId: string | null
    managerId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    branchId: string | null
    managerId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    code: number
    branchId: number
    managerId: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    branchId?: true
    managerId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    branchId?: true
    managerId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    branchId?: true
    managerId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    code: string
    branchId: string | null
    managerId: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    branchId?: boolean
    managerId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Department$branchArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    branchId?: boolean
    managerId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Department$branchArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    branchId?: boolean
    managerId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Department$branchArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Department$branchArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      manager: Prisma.$EmployeePayload<ExtArgs> | null
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      branchId: string | null
      managerId: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Department$branchArgs<ExtArgs> = {}>(args?: Subset<T, Department$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    manager<T extends Department$managerArgs<ExtArgs> = {}>(args?: Subset<T, Department$managerArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly branchId: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.branch
   */
  export type Department$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Department.manager
   */
  export type Department$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Designation
   */

  export type AggregateDesignation = {
    _count: DesignationCountAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  export type DesignationMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignationMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignationMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignationCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designation to aggregate.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designations
    **/
    _count?: true | DesignationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignationMaxAggregateInputType
  }

  export type GetDesignationAggregateType<T extends DesignationAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignation[P]>
      : GetScalarType<T[P], AggregateDesignation[P]>
  }




  export type DesignationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignationWhereInput
    orderBy?: DesignationOrderByWithAggregationInput | DesignationOrderByWithAggregationInput[]
    by: DesignationScalarFieldEnum[] | DesignationScalarFieldEnum
    having?: DesignationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignationCountAggregateInputType | true
    _min?: DesignationMinAggregateInputType
    _max?: DesignationMaxAggregateInputType
  }

  export type DesignationGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DesignationCountAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  type GetDesignationGroupByPayload<T extends DesignationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignationGroupByOutputType[P]>
            : GetScalarType<T[P], DesignationGroupByOutputType[P]>
        }
      >
    >


  export type DesignationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Designation$employeesArgs<ExtArgs>
    _count?: boolean | DesignationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Designation$employeesArgs<ExtArgs>
    _count?: boolean | DesignationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DesignationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DesignationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Designation"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designation"]>
    composites: {}
  }

  type DesignationGetPayload<S extends boolean | null | undefined | DesignationDefaultArgs> = $Result.GetResult<Prisma.$DesignationPayload, S>

  type DesignationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DesignationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DesignationCountAggregateInputType | true
    }

  export interface DesignationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Designation'], meta: { name: 'Designation' } }
    /**
     * Find zero or one Designation that matches the filter.
     * @param {DesignationFindUniqueArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignationFindUniqueArgs>(args: SelectSubset<T, DesignationFindUniqueArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Designation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DesignationFindUniqueOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignationFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Designation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignationFindFirstArgs>(args?: SelectSubset<T, DesignationFindFirstArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Designation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignationFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Designations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designations
     * const designations = await prisma.designation.findMany()
     * 
     * // Get first 10 Designations
     * const designations = await prisma.designation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designationWithIdOnly = await prisma.designation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignationFindManyArgs>(args?: SelectSubset<T, DesignationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Designation.
     * @param {DesignationCreateArgs} args - Arguments to create a Designation.
     * @example
     * // Create one Designation
     * const Designation = await prisma.designation.create({
     *   data: {
     *     // ... data to create a Designation
     *   }
     * })
     * 
     */
    create<T extends DesignationCreateArgs>(args: SelectSubset<T, DesignationCreateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Designations.
     * @param {DesignationCreateManyArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignationCreateManyArgs>(args?: SelectSubset<T, DesignationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Designations and returns the data saved in the database.
     * @param {DesignationCreateManyAndReturnArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Designations and only return the `id`
     * const designationWithIdOnly = await prisma.designation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignationCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Designation.
     * @param {DesignationDeleteArgs} args - Arguments to delete one Designation.
     * @example
     * // Delete one Designation
     * const Designation = await prisma.designation.delete({
     *   where: {
     *     // ... filter to delete one Designation
     *   }
     * })
     * 
     */
    delete<T extends DesignationDeleteArgs>(args: SelectSubset<T, DesignationDeleteArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Designation.
     * @param {DesignationUpdateArgs} args - Arguments to update one Designation.
     * @example
     * // Update one Designation
     * const designation = await prisma.designation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignationUpdateArgs>(args: SelectSubset<T, DesignationUpdateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Designations.
     * @param {DesignationDeleteManyArgs} args - Arguments to filter Designations to delete.
     * @example
     * // Delete a few Designations
     * const { count } = await prisma.designation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignationDeleteManyArgs>(args?: SelectSubset<T, DesignationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignationUpdateManyArgs>(args: SelectSubset<T, DesignationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Designation.
     * @param {DesignationUpsertArgs} args - Arguments to update or create a Designation.
     * @example
     * // Update or create a Designation
     * const designation = await prisma.designation.upsert({
     *   create: {
     *     // ... data to create a Designation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Designation we want to update
     *   }
     * })
     */
    upsert<T extends DesignationUpsertArgs>(args: SelectSubset<T, DesignationUpsertArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationCountArgs} args - Arguments to filter Designations to count.
     * @example
     * // Count the number of Designations
     * const count = await prisma.designation.count({
     *   where: {
     *     // ... the filter for the Designations we want to count
     *   }
     * })
    **/
    count<T extends DesignationCountArgs>(
      args?: Subset<T, DesignationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignationAggregateArgs>(args: Subset<T, DesignationAggregateArgs>): Prisma.PrismaPromise<GetDesignationAggregateType<T>>

    /**
     * Group by Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignationGroupByArgs['orderBy'] }
        : { orderBy?: DesignationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Designation model
   */
  readonly fields: DesignationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Designation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Designation$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Designation$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Designation model
   */ 
  interface DesignationFieldRefs {
    readonly id: FieldRef<"Designation", 'String'>
    readonly name: FieldRef<"Designation", 'String'>
    readonly code: FieldRef<"Designation", 'String'>
    readonly description: FieldRef<"Designation", 'String'>
    readonly isActive: FieldRef<"Designation", 'Boolean'>
    readonly createdAt: FieldRef<"Designation", 'DateTime'>
    readonly updatedAt: FieldRef<"Designation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Designation findUnique
   */
  export type DesignationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findUniqueOrThrow
   */
  export type DesignationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findFirst
   */
  export type DesignationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findFirstOrThrow
   */
  export type DesignationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findMany
   */
  export type DesignationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designations to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation create
   */
  export type DesignationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to create a Designation.
     */
    data: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
  }

  /**
   * Designation createMany
   */
  export type DesignationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Designation createManyAndReturn
   */
  export type DesignationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Designation update
   */
  export type DesignationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to update a Designation.
     */
    data: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
    /**
     * Choose, which Designation to update.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation updateMany
   */
  export type DesignationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
  }

  /**
   * Designation upsert
   */
  export type DesignationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The filter to search for the Designation to update in case it exists.
     */
    where: DesignationWhereUniqueInput
    /**
     * In case the Designation found by the `where` argument doesn't exist, create a new Designation with this data.
     */
    create: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
    /**
     * In case the Designation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
  }

  /**
   * Designation delete
   */
  export type DesignationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter which Designation to delete.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation deleteMany
   */
  export type DesignationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designations to delete
     */
    where?: DesignationWhereInput
  }

  /**
   * Designation.employees
   */
  export type Designation$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Designation without action
   */
  export type DesignationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Category$employeesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Category$employeesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Category$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Category$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly code: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.employees
   */
  export type Category$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    basicSalary: number | null
    hra: number | null
    conveyance: number | null
    medicalAllowance: number | null
    specialAllowance: number | null
    otherAllowances: number | null
    standardDeductions: number | null
    otRateMultiplier: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    basicSalary: number | null
    hra: number | null
    conveyance: number | null
    medicalAllowance: number | null
    specialAllowance: number | null
    otherAllowances: number | null
    standardDeductions: number | null
    otRateMultiplier: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    branchId: string | null
    departmentId: string | null
    designationId: string | null
    categoryId: string | null
    shiftId: string | null
    deviceUserId: string | null
    sourceEmployeeId: string | null
    dateOfJoining: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    basicSalary: number | null
    hra: number | null
    conveyance: number | null
    medicalAllowance: number | null
    specialAllowance: number | null
    otherAllowances: number | null
    standardDeductions: number | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    aadhaarNumber: string | null
    isPFEnabled: boolean | null
    isESIEnabled: boolean | null
    isPTEnabled: boolean | null
    isOTEnabled: boolean | null
    otRateMultiplier: number | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    branchId: string | null
    departmentId: string | null
    designationId: string | null
    categoryId: string | null
    shiftId: string | null
    deviceUserId: string | null
    sourceEmployeeId: string | null
    dateOfJoining: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    basicSalary: number | null
    hra: number | null
    conveyance: number | null
    medicalAllowance: number | null
    specialAllowance: number | null
    otherAllowances: number | null
    standardDeductions: number | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    aadhaarNumber: string | null
    isPFEnabled: boolean | null
    isESIEnabled: boolean | null
    isPTEnabled: boolean | null
    isOTEnabled: boolean | null
    otRateMultiplier: number | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeCode: number
    firstName: number
    lastName: number
    email: number
    phone: number
    branchId: number
    departmentId: number
    designationId: number
    categoryId: number
    shiftId: number
    deviceUserId: number
    sourceEmployeeId: number
    dateOfJoining: number
    isActive: number
    createdAt: number
    updatedAt: number
    basicSalary: number
    hra: number
    conveyance: number
    medicalAllowance: number
    specialAllowance: number
    otherAllowances: number
    standardDeductions: number
    bankName: number
    accountNumber: number
    ifscCode: number
    panNumber: number
    aadhaarNumber: number
    isPFEnabled: number
    isESIEnabled: number
    isPTEnabled: number
    isOTEnabled: number
    otRateMultiplier: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    basicSalary?: true
    hra?: true
    conveyance?: true
    medicalAllowance?: true
    specialAllowance?: true
    otherAllowances?: true
    standardDeductions?: true
    otRateMultiplier?: true
  }

  export type EmployeeSumAggregateInputType = {
    basicSalary?: true
    hra?: true
    conveyance?: true
    medicalAllowance?: true
    specialAllowance?: true
    otherAllowances?: true
    standardDeductions?: true
    otRateMultiplier?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    branchId?: true
    departmentId?: true
    designationId?: true
    categoryId?: true
    shiftId?: true
    deviceUserId?: true
    sourceEmployeeId?: true
    dateOfJoining?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    basicSalary?: true
    hra?: true
    conveyance?: true
    medicalAllowance?: true
    specialAllowance?: true
    otherAllowances?: true
    standardDeductions?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    aadhaarNumber?: true
    isPFEnabled?: true
    isESIEnabled?: true
    isPTEnabled?: true
    isOTEnabled?: true
    otRateMultiplier?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    branchId?: true
    departmentId?: true
    designationId?: true
    categoryId?: true
    shiftId?: true
    deviceUserId?: true
    sourceEmployeeId?: true
    dateOfJoining?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    basicSalary?: true
    hra?: true
    conveyance?: true
    medicalAllowance?: true
    specialAllowance?: true
    otherAllowances?: true
    standardDeductions?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    aadhaarNumber?: true
    isPFEnabled?: true
    isESIEnabled?: true
    isPTEnabled?: true
    isOTEnabled?: true
    otRateMultiplier?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    branchId?: true
    departmentId?: true
    designationId?: true
    categoryId?: true
    shiftId?: true
    deviceUserId?: true
    sourceEmployeeId?: true
    dateOfJoining?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    basicSalary?: true
    hra?: true
    conveyance?: true
    medicalAllowance?: true
    specialAllowance?: true
    otherAllowances?: true
    standardDeductions?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    panNumber?: true
    aadhaarNumber?: true
    isPFEnabled?: true
    isESIEnabled?: true
    isPTEnabled?: true
    isOTEnabled?: true
    otRateMultiplier?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employeeCode: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    branchId: string | null
    departmentId: string | null
    designationId: string | null
    categoryId: string | null
    shiftId: string | null
    deviceUserId: string | null
    sourceEmployeeId: string | null
    dateOfJoining: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    basicSalary: number
    hra: number
    conveyance: number
    medicalAllowance: number
    specialAllowance: number
    otherAllowances: number
    standardDeductions: number
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    panNumber: string | null
    aadhaarNumber: string | null
    isPFEnabled: boolean
    isESIEnabled: boolean
    isPTEnabled: boolean
    isOTEnabled: boolean
    otRateMultiplier: number
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    branchId?: boolean
    departmentId?: boolean
    designationId?: boolean
    categoryId?: boolean
    shiftId?: boolean
    deviceUserId?: boolean
    sourceEmployeeId?: boolean
    dateOfJoining?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    basicSalary?: boolean
    hra?: boolean
    conveyance?: boolean
    medicalAllowance?: boolean
    specialAllowance?: boolean
    otherAllowances?: boolean
    standardDeductions?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: boolean
    branch?: boolean | Employee$branchArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    designation?: boolean | Employee$designationArgs<ExtArgs>
    category?: boolean | Employee$categoryArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    managedDepartments?: boolean | Employee$managedDepartmentsArgs<ExtArgs>
    managerApprovedLeaves?: boolean | Employee$managerApprovedLeavesArgs<ExtArgs>
    ceoApprovedLeaves?: boolean | Employee$ceoApprovedLeavesArgs<ExtArgs>
    attendanceLogs?: boolean | Employee$attendanceLogsArgs<ExtArgs>
    leaveEntries?: boolean | Employee$leaveEntriesArgs<ExtArgs>
    employeeShifts?: boolean | Employee$employeeShiftsArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    branchId?: boolean
    departmentId?: boolean
    designationId?: boolean
    categoryId?: boolean
    shiftId?: boolean
    deviceUserId?: boolean
    sourceEmployeeId?: boolean
    dateOfJoining?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    basicSalary?: boolean
    hra?: boolean
    conveyance?: boolean
    medicalAllowance?: boolean
    specialAllowance?: boolean
    otherAllowances?: boolean
    standardDeductions?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: boolean
    branch?: boolean | Employee$branchArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    designation?: boolean | Employee$designationArgs<ExtArgs>
    category?: boolean | Employee$categoryArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    branchId?: boolean
    departmentId?: boolean
    designationId?: boolean
    categoryId?: boolean
    shiftId?: boolean
    deviceUserId?: boolean
    sourceEmployeeId?: boolean
    dateOfJoining?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    basicSalary?: boolean
    hra?: boolean
    conveyance?: boolean
    medicalAllowance?: boolean
    specialAllowance?: boolean
    otherAllowances?: boolean
    standardDeductions?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Employee$branchArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    designation?: boolean | Employee$designationArgs<ExtArgs>
    category?: boolean | Employee$categoryArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    managedDepartments?: boolean | Employee$managedDepartmentsArgs<ExtArgs>
    managerApprovedLeaves?: boolean | Employee$managerApprovedLeavesArgs<ExtArgs>
    ceoApprovedLeaves?: boolean | Employee$ceoApprovedLeavesArgs<ExtArgs>
    attendanceLogs?: boolean | Employee$attendanceLogsArgs<ExtArgs>
    leaveEntries?: boolean | Employee$leaveEntriesArgs<ExtArgs>
    employeeShifts?: boolean | Employee$employeeShiftsArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Employee$branchArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    designation?: boolean | Employee$designationArgs<ExtArgs>
    category?: boolean | Employee$categoryArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      designation: Prisma.$DesignationPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      shift: Prisma.$ShiftPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      managedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      managerApprovedLeaves: Prisma.$LeaveEntryPayload<ExtArgs>[]
      ceoApprovedLeaves: Prisma.$LeaveEntryPayload<ExtArgs>[]
      attendanceLogs: Prisma.$AttendanceLogPayload<ExtArgs>[]
      leaveEntries: Prisma.$LeaveEntryPayload<ExtArgs>[]
      employeeShifts: Prisma.$EmployeeShiftPayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeCode: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      branchId: string | null
      departmentId: string | null
      designationId: string | null
      categoryId: string | null
      shiftId: string | null
      deviceUserId: string | null
      sourceEmployeeId: string | null
      dateOfJoining: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      basicSalary: number
      hra: number
      conveyance: number
      medicalAllowance: number
      specialAllowance: number
      otherAllowances: number
      standardDeductions: number
      bankName: string | null
      accountNumber: string | null
      ifscCode: string | null
      panNumber: string | null
      aadhaarNumber: string | null
      isPFEnabled: boolean
      isESIEnabled: boolean
      isPTEnabled: boolean
      isOTEnabled: boolean
      otRateMultiplier: number
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Employee$branchArgs<ExtArgs> = {}>(args?: Subset<T, Employee$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    designation<T extends Employee$designationArgs<ExtArgs> = {}>(args?: Subset<T, Employee$designationArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends Employee$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Employee$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shift<T extends Employee$shiftArgs<ExtArgs> = {}>(args?: Subset<T, Employee$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    managedDepartments<T extends Employee$managedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$managedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    managerApprovedLeaves<T extends Employee$managerApprovedLeavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$managerApprovedLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findMany"> | Null>
    ceoApprovedLeaves<T extends Employee$ceoApprovedLeavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ceoApprovedLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findMany"> | Null>
    attendanceLogs<T extends Employee$attendanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany"> | Null>
    leaveEntries<T extends Employee$leaveEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leaveEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeShifts<T extends Employee$employeeShiftsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employeeShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany"> | Null>
    payrolls<T extends Employee$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employeeCode: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly branchId: FieldRef<"Employee", 'String'>
    readonly departmentId: FieldRef<"Employee", 'String'>
    readonly designationId: FieldRef<"Employee", 'String'>
    readonly categoryId: FieldRef<"Employee", 'String'>
    readonly shiftId: FieldRef<"Employee", 'String'>
    readonly deviceUserId: FieldRef<"Employee", 'String'>
    readonly sourceEmployeeId: FieldRef<"Employee", 'String'>
    readonly dateOfJoining: FieldRef<"Employee", 'DateTime'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly basicSalary: FieldRef<"Employee", 'Float'>
    readonly hra: FieldRef<"Employee", 'Float'>
    readonly conveyance: FieldRef<"Employee", 'Float'>
    readonly medicalAllowance: FieldRef<"Employee", 'Float'>
    readonly specialAllowance: FieldRef<"Employee", 'Float'>
    readonly otherAllowances: FieldRef<"Employee", 'Float'>
    readonly standardDeductions: FieldRef<"Employee", 'Float'>
    readonly bankName: FieldRef<"Employee", 'String'>
    readonly accountNumber: FieldRef<"Employee", 'String'>
    readonly ifscCode: FieldRef<"Employee", 'String'>
    readonly panNumber: FieldRef<"Employee", 'String'>
    readonly aadhaarNumber: FieldRef<"Employee", 'String'>
    readonly isPFEnabled: FieldRef<"Employee", 'Boolean'>
    readonly isESIEnabled: FieldRef<"Employee", 'Boolean'>
    readonly isPTEnabled: FieldRef<"Employee", 'Boolean'>
    readonly isOTEnabled: FieldRef<"Employee", 'Boolean'>
    readonly otRateMultiplier: FieldRef<"Employee", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.branch
   */
  export type Employee$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee.designation
   */
  export type Employee$designationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    where?: DesignationWhereInput
  }

  /**
   * Employee.category
   */
  export type Employee$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Employee.shift
   */
  export type Employee$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.managedDepartments
   */
  export type Employee$managedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Employee.managerApprovedLeaves
   */
  export type Employee$managerApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    where?: LeaveEntryWhereInput
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    cursor?: LeaveEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * Employee.ceoApprovedLeaves
   */
  export type Employee$ceoApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    where?: LeaveEntryWhereInput
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    cursor?: LeaveEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * Employee.attendanceLogs
   */
  export type Employee$attendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * Employee.leaveEntries
   */
  export type Employee$leaveEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    where?: LeaveEntryWhereInput
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    cursor?: LeaveEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * Employee.employeeShifts
   */
  export type Employee$employeeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    cursor?: EmployeeShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * Employee.payrolls
   */
  export type Employee$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model CompanyProfile
   */

  export type AggregateCompanyProfile = {
    _count: CompanyProfileCountAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  export type CompanyProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    address: string | null
    logo: string | null
    gstin: string | null
    pan: string | null
    pfCode: string | null
    esiCode: string | null
    tan: string | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    address: string | null
    logo: string | null
    gstin: string | null
    pan: string | null
    pfCode: string | null
    esiCode: string | null
    tan: string | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    address: number
    logo: number
    gstin: number
    pan: number
    pfCode: number
    esiCode: number
    tan: number
    bankName: number
    accountNumber: number
    ifscCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyProfileMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    address?: true
    logo?: true
    gstin?: true
    pan?: true
    pfCode?: true
    esiCode?: true
    tan?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    address?: true
    logo?: true
    gstin?: true
    pan?: true
    pfCode?: true
    esiCode?: true
    tan?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    address?: true
    logo?: true
    gstin?: true
    pan?: true
    pfCode?: true
    esiCode?: true
    tan?: true
    bankName?: true
    accountNumber?: true
    ifscCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfile to aggregate.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyProfiles
    **/
    _count?: true | CompanyProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type GetCompanyProfileAggregateType<T extends CompanyProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyProfile[P]>
      : GetScalarType<T[P], AggregateCompanyProfile[P]>
  }




  export type CompanyProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyProfileWhereInput
    orderBy?: CompanyProfileOrderByWithAggregationInput | CompanyProfileOrderByWithAggregationInput[]
    by: CompanyProfileScalarFieldEnum[] | CompanyProfileScalarFieldEnum
    having?: CompanyProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyProfileCountAggregateInputType | true
    _min?: CompanyProfileMinAggregateInputType
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type CompanyProfileGroupByOutputType = {
    id: string
    name: string
    legalName: string | null
    address: string | null
    logo: string | null
    gstin: string | null
    pan: string | null
    pfCode: string | null
    esiCode: string | null
    tan: string | null
    bankName: string | null
    accountNumber: string | null
    ifscCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyProfileCountAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  type GetCompanyProfileGroupByPayload<T extends CompanyProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
        }
      >
    >


  export type CompanyProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    address?: boolean
    logo?: boolean
    gstin?: boolean
    pan?: boolean
    pfCode?: boolean
    esiCode?: boolean
    tan?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    address?: boolean
    logo?: boolean
    gstin?: boolean
    pan?: boolean
    pfCode?: boolean
    esiCode?: boolean
    tan?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectScalar = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    address?: boolean
    logo?: boolean
    gstin?: boolean
    pan?: boolean
    pfCode?: boolean
    esiCode?: boolean
    tan?: boolean
    bankName?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CompanyProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      legalName: string | null
      address: string | null
      logo: string | null
      gstin: string | null
      pan: string | null
      pfCode: string | null
      esiCode: string | null
      tan: string | null
      bankName: string | null
      accountNumber: string | null
      ifscCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyProfile"]>
    composites: {}
  }

  type CompanyProfileGetPayload<S extends boolean | null | undefined | CompanyProfileDefaultArgs> = $Result.GetResult<Prisma.$CompanyProfilePayload, S>

  type CompanyProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyProfileCountAggregateInputType | true
    }

  export interface CompanyProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyProfile'], meta: { name: 'CompanyProfile' } }
    /**
     * Find zero or one CompanyProfile that matches the filter.
     * @param {CompanyProfileFindUniqueArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyProfileFindUniqueArgs>(args: SelectSubset<T, CompanyProfileFindUniqueArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyProfileFindUniqueOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyProfileFindFirstArgs>(args?: SelectSubset<T, CompanyProfileFindFirstArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany()
     * 
     * // Get first 10 CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyProfileFindManyArgs>(args?: SelectSubset<T, CompanyProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyProfile.
     * @param {CompanyProfileCreateArgs} args - Arguments to create a CompanyProfile.
     * @example
     * // Create one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.create({
     *   data: {
     *     // ... data to create a CompanyProfile
     *   }
     * })
     * 
     */
    create<T extends CompanyProfileCreateArgs>(args: SelectSubset<T, CompanyProfileCreateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyProfiles.
     * @param {CompanyProfileCreateManyArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyProfileCreateManyArgs>(args?: SelectSubset<T, CompanyProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyProfiles and returns the data saved in the database.
     * @param {CompanyProfileCreateManyAndReturnArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyProfiles and only return the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyProfile.
     * @param {CompanyProfileDeleteArgs} args - Arguments to delete one CompanyProfile.
     * @example
     * // Delete one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.delete({
     *   where: {
     *     // ... filter to delete one CompanyProfile
     *   }
     * })
     * 
     */
    delete<T extends CompanyProfileDeleteArgs>(args: SelectSubset<T, CompanyProfileDeleteArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyProfile.
     * @param {CompanyProfileUpdateArgs} args - Arguments to update one CompanyProfile.
     * @example
     * // Update one CompanyProfile
     * const companyProfile = await prisma.companyProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyProfileUpdateArgs>(args: SelectSubset<T, CompanyProfileUpdateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyProfiles.
     * @param {CompanyProfileDeleteManyArgs} args - Arguments to filter CompanyProfiles to delete.
     * @example
     * // Delete a few CompanyProfiles
     * const { count } = await prisma.companyProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyProfileDeleteManyArgs>(args?: SelectSubset<T, CompanyProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyProfileUpdateManyArgs>(args: SelectSubset<T, CompanyProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyProfile.
     * @param {CompanyProfileUpsertArgs} args - Arguments to update or create a CompanyProfile.
     * @example
     * // Update or create a CompanyProfile
     * const companyProfile = await prisma.companyProfile.upsert({
     *   create: {
     *     // ... data to create a CompanyProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyProfile we want to update
     *   }
     * })
     */
    upsert<T extends CompanyProfileUpsertArgs>(args: SelectSubset<T, CompanyProfileUpsertArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileCountArgs} args - Arguments to filter CompanyProfiles to count.
     * @example
     * // Count the number of CompanyProfiles
     * const count = await prisma.companyProfile.count({
     *   where: {
     *     // ... the filter for the CompanyProfiles we want to count
     *   }
     * })
    **/
    count<T extends CompanyProfileCountArgs>(
      args?: Subset<T, CompanyProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyProfileAggregateArgs>(args: Subset<T, CompanyProfileAggregateArgs>): Prisma.PrismaPromise<GetCompanyProfileAggregateType<T>>

    /**
     * Group by CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyProfileGroupByArgs['orderBy'] }
        : { orderBy?: CompanyProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyProfile model
   */
  readonly fields: CompanyProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyProfile model
   */ 
  interface CompanyProfileFieldRefs {
    readonly id: FieldRef<"CompanyProfile", 'String'>
    readonly name: FieldRef<"CompanyProfile", 'String'>
    readonly legalName: FieldRef<"CompanyProfile", 'String'>
    readonly address: FieldRef<"CompanyProfile", 'String'>
    readonly logo: FieldRef<"CompanyProfile", 'String'>
    readonly gstin: FieldRef<"CompanyProfile", 'String'>
    readonly pan: FieldRef<"CompanyProfile", 'String'>
    readonly pfCode: FieldRef<"CompanyProfile", 'String'>
    readonly esiCode: FieldRef<"CompanyProfile", 'String'>
    readonly tan: FieldRef<"CompanyProfile", 'String'>
    readonly bankName: FieldRef<"CompanyProfile", 'String'>
    readonly accountNumber: FieldRef<"CompanyProfile", 'String'>
    readonly ifscCode: FieldRef<"CompanyProfile", 'String'>
    readonly createdAt: FieldRef<"CompanyProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyProfile findUnique
   */
  export type CompanyProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findUniqueOrThrow
   */
  export type CompanyProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findFirst
   */
  export type CompanyProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findFirstOrThrow
   */
  export type CompanyProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findMany
   */
  export type CompanyProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter, which CompanyProfiles to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile create
   */
  export type CompanyProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a CompanyProfile.
     */
    data: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
  }

  /**
   * CompanyProfile createMany
   */
  export type CompanyProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProfile createManyAndReturn
   */
  export type CompanyProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProfile update
   */
  export type CompanyProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a CompanyProfile.
     */
    data: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
    /**
     * Choose, which CompanyProfile to update.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile updateMany
   */
  export type CompanyProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyProfiles.
     */
    data: XOR<CompanyProfileUpdateManyMutationInput, CompanyProfileUncheckedUpdateManyInput>
    /**
     * Filter which CompanyProfiles to update
     */
    where?: CompanyProfileWhereInput
  }

  /**
   * CompanyProfile upsert
   */
  export type CompanyProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the CompanyProfile to update in case it exists.
     */
    where: CompanyProfileWhereUniqueInput
    /**
     * In case the CompanyProfile found by the `where` argument doesn't exist, create a new CompanyProfile with this data.
     */
    create: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
    /**
     * In case the CompanyProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
  }

  /**
   * CompanyProfile delete
   */
  export type CompanyProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Filter which CompanyProfile to delete.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile deleteMany
   */
  export type CompanyProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfiles to delete
     */
    where?: CompanyProfileWhereInput
  }

  /**
   * CompanyProfile without action
   */
  export type CompanyProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    gracePeriodIn: number | null
    gracePeriodOut: number | null
  }

  export type ShiftSumAggregateOutputType = {
    gracePeriodIn: number | null
    gracePeriodOut: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    gracePeriodIn: number | null
    gracePeriodOut: number | null
    isNightShift: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    gracePeriodIn: number | null
    gracePeriodOut: number | null
    isNightShift: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    gracePeriodIn: number
    gracePeriodOut: number
    isNightShift: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    gracePeriodIn?: true
    gracePeriodOut?: true
  }

  export type ShiftSumAggregateInputType = {
    gracePeriodIn?: true
    gracePeriodOut?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    gracePeriodIn?: true
    gracePeriodOut?: true
    isNightShift?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    gracePeriodIn?: true
    gracePeriodOut?: true
    isNightShift?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    gracePeriodIn?: true
    gracePeriodOut?: true
    isNightShift?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn: number
    gracePeriodOut: number
    isNightShift: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    gracePeriodIn?: boolean
    gracePeriodOut?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    employeeShifts?: boolean | Shift$employeeShiftsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    gracePeriodIn?: boolean
    gracePeriodOut?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    gracePeriodIn?: boolean
    gracePeriodOut?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    employeeShifts?: boolean | Shift$employeeShiftsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      employeeShifts: Prisma.$EmployeeShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startTime: string
      endTime: string
      gracePeriodIn: number
      gracePeriodOut: number
      isNightShift: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Shift$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Shift$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    employeeShifts<T extends Shift$employeeShiftsArgs<ExtArgs> = {}>(args?: Subset<T, Shift$employeeShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'String'>
    readonly endTime: FieldRef<"Shift", 'String'>
    readonly gracePeriodIn: FieldRef<"Shift", 'Int'>
    readonly gracePeriodOut: FieldRef<"Shift", 'Int'>
    readonly isNightShift: FieldRef<"Shift", 'Boolean'>
    readonly isActive: FieldRef<"Shift", 'Boolean'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift.employees
   */
  export type Shift$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Shift.employeeShifts
   */
  export type Shift$employeeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    cursor?: EmployeeShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeShift
   */

  export type AggregateEmployeeShift = {
    _count: EmployeeShiftCountAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  export type EmployeeShiftMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeShiftMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeShiftCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeShiftMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeShiftMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeShiftCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShift to aggregate.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeShifts
    **/
    _count?: true | EmployeeShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type GetEmployeeShiftAggregateType<T extends EmployeeShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeShift[P]>
      : GetScalarType<T[P], AggregateEmployeeShift[P]>
  }




  export type EmployeeShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithAggregationInput | EmployeeShiftOrderByWithAggregationInput[]
    by: EmployeeShiftScalarFieldEnum[] | EmployeeShiftScalarFieldEnum
    having?: EmployeeShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeShiftCountAggregateInputType | true
    _min?: EmployeeShiftMinAggregateInputType
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type EmployeeShiftGroupByOutputType = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeShiftCountAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  type GetEmployeeShiftGroupByPayload<T extends EmployeeShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeShift"]>

  export type EmployeeShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeShift"]>

  export type EmployeeShiftSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }
  export type EmployeeShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }

  export type $EmployeeShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeShift"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      shiftId: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeShift"]>
    composites: {}
  }

  type EmployeeShiftGetPayload<S extends boolean | null | undefined | EmployeeShiftDefaultArgs> = $Result.GetResult<Prisma.$EmployeeShiftPayload, S>

  type EmployeeShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeShiftCountAggregateInputType | true
    }

  export interface EmployeeShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeShift'], meta: { name: 'EmployeeShift' } }
    /**
     * Find zero or one EmployeeShift that matches the filter.
     * @param {EmployeeShiftFindUniqueArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeShiftFindUniqueArgs>(args: SelectSubset<T, EmployeeShiftFindUniqueArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeShift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeShiftFindUniqueOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeShiftFindFirstArgs>(args?: SelectSubset<T, EmployeeShiftFindFirstArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany()
     * 
     * // Get first 10 EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeShiftWithIdOnly = await prisma.employeeShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeShiftFindManyArgs>(args?: SelectSubset<T, EmployeeShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeShift.
     * @param {EmployeeShiftCreateArgs} args - Arguments to create a EmployeeShift.
     * @example
     * // Create one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.create({
     *   data: {
     *     // ... data to create a EmployeeShift
     *   }
     * })
     * 
     */
    create<T extends EmployeeShiftCreateArgs>(args: SelectSubset<T, EmployeeShiftCreateArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeShifts.
     * @param {EmployeeShiftCreateManyArgs} args - Arguments to create many EmployeeShifts.
     * @example
     * // Create many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeShiftCreateManyArgs>(args?: SelectSubset<T, EmployeeShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeShifts and returns the data saved in the database.
     * @param {EmployeeShiftCreateManyAndReturnArgs} args - Arguments to create many EmployeeShifts.
     * @example
     * // Create many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeShifts and only return the `id`
     * const employeeShiftWithIdOnly = await prisma.employeeShift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeShift.
     * @param {EmployeeShiftDeleteArgs} args - Arguments to delete one EmployeeShift.
     * @example
     * // Delete one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.delete({
     *   where: {
     *     // ... filter to delete one EmployeeShift
     *   }
     * })
     * 
     */
    delete<T extends EmployeeShiftDeleteArgs>(args: SelectSubset<T, EmployeeShiftDeleteArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeShift.
     * @param {EmployeeShiftUpdateArgs} args - Arguments to update one EmployeeShift.
     * @example
     * // Update one EmployeeShift
     * const employeeShift = await prisma.employeeShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeShiftUpdateArgs>(args: SelectSubset<T, EmployeeShiftUpdateArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeShifts.
     * @param {EmployeeShiftDeleteManyArgs} args - Arguments to filter EmployeeShifts to delete.
     * @example
     * // Delete a few EmployeeShifts
     * const { count } = await prisma.employeeShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeShiftDeleteManyArgs>(args?: SelectSubset<T, EmployeeShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeShiftUpdateManyArgs>(args: SelectSubset<T, EmployeeShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeShift.
     * @param {EmployeeShiftUpsertArgs} args - Arguments to update or create a EmployeeShift.
     * @example
     * // Update or create a EmployeeShift
     * const employeeShift = await prisma.employeeShift.upsert({
     *   create: {
     *     // ... data to create a EmployeeShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeShift we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeShiftUpsertArgs>(args: SelectSubset<T, EmployeeShiftUpsertArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftCountArgs} args - Arguments to filter EmployeeShifts to count.
     * @example
     * // Count the number of EmployeeShifts
     * const count = await prisma.employeeShift.count({
     *   where: {
     *     // ... the filter for the EmployeeShifts we want to count
     *   }
     * })
    **/
    count<T extends EmployeeShiftCountArgs>(
      args?: Subset<T, EmployeeShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeShiftAggregateArgs>(args: Subset<T, EmployeeShiftAggregateArgs>): Prisma.PrismaPromise<GetEmployeeShiftAggregateType<T>>

    /**
     * Group by EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeShiftGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeShift model
   */
  readonly fields: EmployeeShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeShift model
   */ 
  interface EmployeeShiftFieldRefs {
    readonly id: FieldRef<"EmployeeShift", 'String'>
    readonly employeeId: FieldRef<"EmployeeShift", 'String'>
    readonly shiftId: FieldRef<"EmployeeShift", 'String'>
    readonly startDate: FieldRef<"EmployeeShift", 'DateTime'>
    readonly endDate: FieldRef<"EmployeeShift", 'DateTime'>
    readonly createdAt: FieldRef<"EmployeeShift", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeShift findUnique
   */
  export type EmployeeShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift findUniqueOrThrow
   */
  export type EmployeeShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift findFirst
   */
  export type EmployeeShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift findFirstOrThrow
   */
  export type EmployeeShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift findMany
   */
  export type EmployeeShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShifts to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift create
   */
  export type EmployeeShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeShift.
     */
    data: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
  }

  /**
   * EmployeeShift createMany
   */
  export type EmployeeShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeShifts.
     */
    data: EmployeeShiftCreateManyInput | EmployeeShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeShift createManyAndReturn
   */
  export type EmployeeShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeShifts.
     */
    data: EmployeeShiftCreateManyInput | EmployeeShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeShift update
   */
  export type EmployeeShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeShift.
     */
    data: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
    /**
     * Choose, which EmployeeShift to update.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift updateMany
   */
  export type EmployeeShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeShifts.
     */
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeShifts to update
     */
    where?: EmployeeShiftWhereInput
  }

  /**
   * EmployeeShift upsert
   */
  export type EmployeeShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeShift to update in case it exists.
     */
    where: EmployeeShiftWhereUniqueInput
    /**
     * In case the EmployeeShift found by the `where` argument doesn't exist, create a new EmployeeShift with this data.
     */
    create: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
    /**
     * In case the EmployeeShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
  }

  /**
   * EmployeeShift delete
   */
  export type EmployeeShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter which EmployeeShift to delete.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift deleteMany
   */
  export type EmployeeShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShifts to delete
     */
    where?: EmployeeShiftWhereInput
  }

  /**
   * EmployeeShift without action
   */
  export type EmployeeShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayMinAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    description: string | null
    isRecurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    description: string | null
    isRecurring: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    date: number
    description: number
    isRecurring: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    description?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    description?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    description?: true
    isRecurring?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: string
    name: string
    date: Date
    description: string | null
    isRecurring: boolean
    createdAt: Date
    updatedAt: Date
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    description?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    description?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    description?: boolean
    isRecurring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      date: Date
      description: string | null
      isRecurring: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'String'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly date: FieldRef<"Holiday", 'DateTime'>
    readonly description: FieldRef<"Holiday", 'String'>
    readonly isRecurring: FieldRef<"Holiday", 'Boolean'>
    readonly createdAt: FieldRef<"Holiday", 'DateTime'>
    readonly updatedAt: FieldRef<"Holiday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
  }


  /**
   * Model LeaveType
   */

  export type AggregateLeaveType = {
    _count: LeaveTypeCountAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  export type LeaveTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isPaid: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isPaid: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isPaid: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveTypeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isPaid?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isPaid?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isPaid?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveType to aggregate.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveTypes
    **/
    _count?: true | LeaveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type GetLeaveTypeAggregateType<T extends LeaveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveType[P]>
      : GetScalarType<T[P], AggregateLeaveType[P]>
  }




  export type LeaveTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithAggregationInput | LeaveTypeOrderByWithAggregationInput[]
    by: LeaveTypeScalarFieldEnum[] | LeaveTypeScalarFieldEnum
    having?: LeaveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveTypeCountAggregateInputType | true
    _min?: LeaveTypeMinAggregateInputType
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type LeaveTypeGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    isPaid: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LeaveTypeCountAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  type GetLeaveTypeGroupByPayload<T extends LeaveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaveTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isPaid?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leaveEntries?: boolean | LeaveType$leaveEntriesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isPaid?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isPaid?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveEntries?: boolean | LeaveType$leaveEntriesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LeaveTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveType"
    objects: {
      leaveEntries: Prisma.$LeaveEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      isPaid: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveType"]>
    composites: {}
  }

  type LeaveTypeGetPayload<S extends boolean | null | undefined | LeaveTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaveTypePayload, S>

  type LeaveTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveTypeCountAggregateInputType | true
    }

  export interface LeaveTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveType'], meta: { name: 'LeaveType' } }
    /**
     * Find zero or one LeaveType that matches the filter.
     * @param {LeaveTypeFindUniqueArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveTypeFindUniqueArgs>(args: SelectSubset<T, LeaveTypeFindUniqueArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveTypeFindFirstArgs>(args?: SelectSubset<T, LeaveTypeFindFirstArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany()
     * 
     * // Get first 10 LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveTypeFindManyArgs>(args?: SelectSubset<T, LeaveTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveType.
     * @param {LeaveTypeCreateArgs} args - Arguments to create a LeaveType.
     * @example
     * // Create one LeaveType
     * const LeaveType = await prisma.leaveType.create({
     *   data: {
     *     // ... data to create a LeaveType
     *   }
     * })
     * 
     */
    create<T extends LeaveTypeCreateArgs>(args: SelectSubset<T, LeaveTypeCreateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveTypes.
     * @param {LeaveTypeCreateManyArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveTypeCreateManyArgs>(args?: SelectSubset<T, LeaveTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveTypes and returns the data saved in the database.
     * @param {LeaveTypeCreateManyAndReturnArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveTypes and only return the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveType.
     * @param {LeaveTypeDeleteArgs} args - Arguments to delete one LeaveType.
     * @example
     * // Delete one LeaveType
     * const LeaveType = await prisma.leaveType.delete({
     *   where: {
     *     // ... filter to delete one LeaveType
     *   }
     * })
     * 
     */
    delete<T extends LeaveTypeDeleteArgs>(args: SelectSubset<T, LeaveTypeDeleteArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveType.
     * @param {LeaveTypeUpdateArgs} args - Arguments to update one LeaveType.
     * @example
     * // Update one LeaveType
     * const leaveType = await prisma.leaveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveTypeUpdateArgs>(args: SelectSubset<T, LeaveTypeUpdateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveTypes.
     * @param {LeaveTypeDeleteManyArgs} args - Arguments to filter LeaveTypes to delete.
     * @example
     * // Delete a few LeaveTypes
     * const { count } = await prisma.leaveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveTypeDeleteManyArgs>(args?: SelectSubset<T, LeaveTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveTypeUpdateManyArgs>(args: SelectSubset<T, LeaveTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveType.
     * @param {LeaveTypeUpsertArgs} args - Arguments to update or create a LeaveType.
     * @example
     * // Update or create a LeaveType
     * const leaveType = await prisma.leaveType.upsert({
     *   create: {
     *     // ... data to create a LeaveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveType we want to update
     *   }
     * })
     */
    upsert<T extends LeaveTypeUpsertArgs>(args: SelectSubset<T, LeaveTypeUpsertArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeCountArgs} args - Arguments to filter LeaveTypes to count.
     * @example
     * // Count the number of LeaveTypes
     * const count = await prisma.leaveType.count({
     *   where: {
     *     // ... the filter for the LeaveTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaveTypeCountArgs>(
      args?: Subset<T, LeaveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveTypeAggregateArgs>(args: Subset<T, LeaveTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaveTypeAggregateType<T>>

    /**
     * Group by LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveType model
   */
  readonly fields: LeaveTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leaveEntries<T extends LeaveType$leaveEntriesArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$leaveEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveType model
   */ 
  interface LeaveTypeFieldRefs {
    readonly id: FieldRef<"LeaveType", 'String'>
    readonly name: FieldRef<"LeaveType", 'String'>
    readonly code: FieldRef<"LeaveType", 'String'>
    readonly description: FieldRef<"LeaveType", 'String'>
    readonly isPaid: FieldRef<"LeaveType", 'Boolean'>
    readonly isActive: FieldRef<"LeaveType", 'Boolean'>
    readonly createdAt: FieldRef<"LeaveType", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveType findUnique
   */
  export type LeaveTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findUniqueOrThrow
   */
  export type LeaveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findFirst
   */
  export type LeaveTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findFirstOrThrow
   */
  export type LeaveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findMany
   */
  export type LeaveTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveTypes to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType create
   */
  export type LeaveTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveType.
     */
    data: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
  }

  /**
   * LeaveType createMany
   */
  export type LeaveTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveType createManyAndReturn
   */
  export type LeaveTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveType update
   */
  export type LeaveTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveType.
     */
    data: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaveType to update.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType updateMany
   */
  export type LeaveTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
  }

  /**
   * LeaveType upsert
   */
  export type LeaveTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveType to update in case it exists.
     */
    where: LeaveTypeWhereUniqueInput
    /**
     * In case the LeaveType found by the `where` argument doesn't exist, create a new LeaveType with this data.
     */
    create: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
    /**
     * In case the LeaveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
  }

  /**
   * LeaveType delete
   */
  export type LeaveTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaveType to delete.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType deleteMany
   */
  export type LeaveTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveTypes to delete
     */
    where?: LeaveTypeWhereInput
  }

  /**
   * LeaveType.leaveEntries
   */
  export type LeaveType$leaveEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    where?: LeaveEntryWhereInput
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    cursor?: LeaveEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * LeaveType without action
   */
  export type LeaveTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
  }


  /**
   * Model LeaveEntry
   */

  export type AggregateLeaveEntry = {
    _count: LeaveEntryCountAggregateOutputType | null
    _avg: LeaveEntryAvgAggregateOutputType | null
    _sum: LeaveEntrySumAggregateOutputType | null
    _min: LeaveEntryMinAggregateOutputType | null
    _max: LeaveEntryMaxAggregateOutputType | null
  }

  export type LeaveEntryAvgAggregateOutputType = {
    days: number | null
  }

  export type LeaveEntrySumAggregateOutputType = {
    days: number | null
  }

  export type LeaveEntryMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    reason: string | null
    status: string | null
    managerApproval: boolean | null
    managerApprovedAt: Date | null
    managerId: string | null
    ceoApproval: boolean | null
    ceoApprovedAt: Date | null
    ceoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveEntryMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    reason: string | null
    status: string | null
    managerApproval: boolean | null
    managerApprovedAt: Date | null
    managerId: string | null
    ceoApproval: boolean | null
    ceoApprovedAt: Date | null
    ceoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveEntryCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveTypeId: number
    startDate: number
    endDate: number
    days: number
    reason: number
    status: number
    managerApproval: number
    managerApprovedAt: number
    managerId: number
    ceoApproval: number
    ceoApprovedAt: number
    ceoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveEntryAvgAggregateInputType = {
    days?: true
  }

  export type LeaveEntrySumAggregateInputType = {
    days?: true
  }

  export type LeaveEntryMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    status?: true
    managerApproval?: true
    managerApprovedAt?: true
    managerId?: true
    ceoApproval?: true
    ceoApprovedAt?: true
    ceoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveEntryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    status?: true
    managerApproval?: true
    managerApprovedAt?: true
    managerId?: true
    ceoApproval?: true
    ceoApprovedAt?: true
    ceoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveEntryCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    reason?: true
    status?: true
    managerApproval?: true
    managerApprovedAt?: true
    managerId?: true
    ceoApproval?: true
    ceoApprovedAt?: true
    ceoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveEntry to aggregate.
     */
    where?: LeaveEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveEntries to fetch.
     */
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveEntries
    **/
    _count?: true | LeaveEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveEntryMaxAggregateInputType
  }

  export type GetLeaveEntryAggregateType<T extends LeaveEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveEntry[P]>
      : GetScalarType<T[P], AggregateLeaveEntry[P]>
  }




  export type LeaveEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveEntryWhereInput
    orderBy?: LeaveEntryOrderByWithAggregationInput | LeaveEntryOrderByWithAggregationInput[]
    by: LeaveEntryScalarFieldEnum[] | LeaveEntryScalarFieldEnum
    having?: LeaveEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveEntryCountAggregateInputType | true
    _avg?: LeaveEntryAvgAggregateInputType
    _sum?: LeaveEntrySumAggregateInputType
    _min?: LeaveEntryMinAggregateInputType
    _max?: LeaveEntryMaxAggregateInputType
  }

  export type LeaveEntryGroupByOutputType = {
    id: string
    employeeId: string
    leaveTypeId: string
    startDate: Date
    endDate: Date
    days: number
    reason: string | null
    status: string
    managerApproval: boolean | null
    managerApprovedAt: Date | null
    managerId: string | null
    ceoApproval: boolean | null
    ceoApprovedAt: Date | null
    ceoId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveEntryCountAggregateOutputType | null
    _avg: LeaveEntryAvgAggregateOutputType | null
    _sum: LeaveEntrySumAggregateOutputType | null
    _min: LeaveEntryMinAggregateOutputType | null
    _max: LeaveEntryMaxAggregateOutputType | null
  }

  type GetLeaveEntryGroupByPayload<T extends LeaveEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaveEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    status?: boolean
    managerApproval?: boolean
    managerApprovedAt?: boolean
    managerId?: boolean
    ceoApproval?: boolean
    ceoApprovedAt?: boolean
    ceoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    manager?: boolean | LeaveEntry$managerArgs<ExtArgs>
    ceo?: boolean | LeaveEntry$ceoArgs<ExtArgs>
  }, ExtArgs["result"]["leaveEntry"]>

  export type LeaveEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    status?: boolean
    managerApproval?: boolean
    managerApprovedAt?: boolean
    managerId?: boolean
    ceoApproval?: boolean
    ceoApprovedAt?: boolean
    ceoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    manager?: boolean | LeaveEntry$managerArgs<ExtArgs>
    ceo?: boolean | LeaveEntry$ceoArgs<ExtArgs>
  }, ExtArgs["result"]["leaveEntry"]>

  export type LeaveEntrySelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    reason?: boolean
    status?: boolean
    managerApproval?: boolean
    managerApprovedAt?: boolean
    managerId?: boolean
    ceoApproval?: boolean
    ceoApprovedAt?: boolean
    ceoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    manager?: boolean | LeaveEntry$managerArgs<ExtArgs>
    ceo?: boolean | LeaveEntry$ceoArgs<ExtArgs>
  }
  export type LeaveEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    manager?: boolean | LeaveEntry$managerArgs<ExtArgs>
    ceo?: boolean | LeaveEntry$ceoArgs<ExtArgs>
  }

  export type $LeaveEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveEntry"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
      manager: Prisma.$EmployeePayload<ExtArgs> | null
      ceo: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      leaveTypeId: string
      startDate: Date
      endDate: Date
      days: number
      reason: string | null
      status: string
      managerApproval: boolean | null
      managerApprovedAt: Date | null
      managerId: string | null
      ceoApproval: boolean | null
      ceoApprovedAt: Date | null
      ceoId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveEntry"]>
    composites: {}
  }

  type LeaveEntryGetPayload<S extends boolean | null | undefined | LeaveEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaveEntryPayload, S>

  type LeaveEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveEntryCountAggregateInputType | true
    }

  export interface LeaveEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveEntry'], meta: { name: 'LeaveEntry' } }
    /**
     * Find zero or one LeaveEntry that matches the filter.
     * @param {LeaveEntryFindUniqueArgs} args - Arguments to find a LeaveEntry
     * @example
     * // Get one LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveEntryFindUniqueArgs>(args: SelectSubset<T, LeaveEntryFindUniqueArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaveEntry
     * @example
     * // Get one LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryFindFirstArgs} args - Arguments to find a LeaveEntry
     * @example
     * // Get one LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveEntryFindFirstArgs>(args?: SelectSubset<T, LeaveEntryFindFirstArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryFindFirstOrThrowArgs} args - Arguments to find a LeaveEntry
     * @example
     * // Get one LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveEntries
     * const leaveEntries = await prisma.leaveEntry.findMany()
     * 
     * // Get first 10 LeaveEntries
     * const leaveEntries = await prisma.leaveEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveEntryWithIdOnly = await prisma.leaveEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveEntryFindManyArgs>(args?: SelectSubset<T, LeaveEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveEntry.
     * @param {LeaveEntryCreateArgs} args - Arguments to create a LeaveEntry.
     * @example
     * // Create one LeaveEntry
     * const LeaveEntry = await prisma.leaveEntry.create({
     *   data: {
     *     // ... data to create a LeaveEntry
     *   }
     * })
     * 
     */
    create<T extends LeaveEntryCreateArgs>(args: SelectSubset<T, LeaveEntryCreateArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveEntries.
     * @param {LeaveEntryCreateManyArgs} args - Arguments to create many LeaveEntries.
     * @example
     * // Create many LeaveEntries
     * const leaveEntry = await prisma.leaveEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveEntryCreateManyArgs>(args?: SelectSubset<T, LeaveEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveEntries and returns the data saved in the database.
     * @param {LeaveEntryCreateManyAndReturnArgs} args - Arguments to create many LeaveEntries.
     * @example
     * // Create many LeaveEntries
     * const leaveEntry = await prisma.leaveEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveEntries and only return the `id`
     * const leaveEntryWithIdOnly = await prisma.leaveEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveEntry.
     * @param {LeaveEntryDeleteArgs} args - Arguments to delete one LeaveEntry.
     * @example
     * // Delete one LeaveEntry
     * const LeaveEntry = await prisma.leaveEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaveEntry
     *   }
     * })
     * 
     */
    delete<T extends LeaveEntryDeleteArgs>(args: SelectSubset<T, LeaveEntryDeleteArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveEntry.
     * @param {LeaveEntryUpdateArgs} args - Arguments to update one LeaveEntry.
     * @example
     * // Update one LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveEntryUpdateArgs>(args: SelectSubset<T, LeaveEntryUpdateArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveEntries.
     * @param {LeaveEntryDeleteManyArgs} args - Arguments to filter LeaveEntries to delete.
     * @example
     * // Delete a few LeaveEntries
     * const { count } = await prisma.leaveEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveEntryDeleteManyArgs>(args?: SelectSubset<T, LeaveEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveEntries
     * const leaveEntry = await prisma.leaveEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveEntryUpdateManyArgs>(args: SelectSubset<T, LeaveEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveEntry.
     * @param {LeaveEntryUpsertArgs} args - Arguments to update or create a LeaveEntry.
     * @example
     * // Update or create a LeaveEntry
     * const leaveEntry = await prisma.leaveEntry.upsert({
     *   create: {
     *     // ... data to create a LeaveEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaveEntryUpsertArgs>(args: SelectSubset<T, LeaveEntryUpsertArgs<ExtArgs>>): Prisma__LeaveEntryClient<$Result.GetResult<Prisma.$LeaveEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryCountArgs} args - Arguments to filter LeaveEntries to count.
     * @example
     * // Count the number of LeaveEntries
     * const count = await prisma.leaveEntry.count({
     *   where: {
     *     // ... the filter for the LeaveEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaveEntryCountArgs>(
      args?: Subset<T, LeaveEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveEntryAggregateArgs>(args: Subset<T, LeaveEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaveEntryAggregateType<T>>

    /**
     * Group by LeaveEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaveEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveEntry model
   */
  readonly fields: LeaveEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends LeaveEntry$managerArgs<ExtArgs> = {}>(args?: Subset<T, LeaveEntry$managerArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ceo<T extends LeaveEntry$ceoArgs<ExtArgs> = {}>(args?: Subset<T, LeaveEntry$ceoArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveEntry model
   */ 
  interface LeaveEntryFieldRefs {
    readonly id: FieldRef<"LeaveEntry", 'String'>
    readonly employeeId: FieldRef<"LeaveEntry", 'String'>
    readonly leaveTypeId: FieldRef<"LeaveEntry", 'String'>
    readonly startDate: FieldRef<"LeaveEntry", 'DateTime'>
    readonly endDate: FieldRef<"LeaveEntry", 'DateTime'>
    readonly days: FieldRef<"LeaveEntry", 'Float'>
    readonly reason: FieldRef<"LeaveEntry", 'String'>
    readonly status: FieldRef<"LeaveEntry", 'String'>
    readonly managerApproval: FieldRef<"LeaveEntry", 'Boolean'>
    readonly managerApprovedAt: FieldRef<"LeaveEntry", 'DateTime'>
    readonly managerId: FieldRef<"LeaveEntry", 'String'>
    readonly ceoApproval: FieldRef<"LeaveEntry", 'Boolean'>
    readonly ceoApprovedAt: FieldRef<"LeaveEntry", 'DateTime'>
    readonly ceoId: FieldRef<"LeaveEntry", 'String'>
    readonly createdAt: FieldRef<"LeaveEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveEntry findUnique
   */
  export type LeaveEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveEntry to fetch.
     */
    where: LeaveEntryWhereUniqueInput
  }

  /**
   * LeaveEntry findUniqueOrThrow
   */
  export type LeaveEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveEntry to fetch.
     */
    where: LeaveEntryWhereUniqueInput
  }

  /**
   * LeaveEntry findFirst
   */
  export type LeaveEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveEntry to fetch.
     */
    where?: LeaveEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveEntries to fetch.
     */
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveEntries.
     */
    cursor?: LeaveEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveEntries.
     */
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * LeaveEntry findFirstOrThrow
   */
  export type LeaveEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveEntry to fetch.
     */
    where?: LeaveEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveEntries to fetch.
     */
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveEntries.
     */
    cursor?: LeaveEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveEntries.
     */
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * LeaveEntry findMany
   */
  export type LeaveEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveEntries to fetch.
     */
    where?: LeaveEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveEntries to fetch.
     */
    orderBy?: LeaveEntryOrderByWithRelationInput | LeaveEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveEntries.
     */
    cursor?: LeaveEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveEntries.
     */
    skip?: number
    distinct?: LeaveEntryScalarFieldEnum | LeaveEntryScalarFieldEnum[]
  }

  /**
   * LeaveEntry create
   */
  export type LeaveEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveEntry.
     */
    data: XOR<LeaveEntryCreateInput, LeaveEntryUncheckedCreateInput>
  }

  /**
   * LeaveEntry createMany
   */
  export type LeaveEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveEntries.
     */
    data: LeaveEntryCreateManyInput | LeaveEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveEntry createManyAndReturn
   */
  export type LeaveEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveEntries.
     */
    data: LeaveEntryCreateManyInput | LeaveEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveEntry update
   */
  export type LeaveEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveEntry.
     */
    data: XOR<LeaveEntryUpdateInput, LeaveEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaveEntry to update.
     */
    where: LeaveEntryWhereUniqueInput
  }

  /**
   * LeaveEntry updateMany
   */
  export type LeaveEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveEntries.
     */
    data: XOR<LeaveEntryUpdateManyMutationInput, LeaveEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaveEntries to update
     */
    where?: LeaveEntryWhereInput
  }

  /**
   * LeaveEntry upsert
   */
  export type LeaveEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveEntry to update in case it exists.
     */
    where: LeaveEntryWhereUniqueInput
    /**
     * In case the LeaveEntry found by the `where` argument doesn't exist, create a new LeaveEntry with this data.
     */
    create: XOR<LeaveEntryCreateInput, LeaveEntryUncheckedCreateInput>
    /**
     * In case the LeaveEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveEntryUpdateInput, LeaveEntryUncheckedUpdateInput>
  }

  /**
   * LeaveEntry delete
   */
  export type LeaveEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaveEntry to delete.
     */
    where: LeaveEntryWhereUniqueInput
  }

  /**
   * LeaveEntry deleteMany
   */
  export type LeaveEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveEntries to delete
     */
    where?: LeaveEntryWhereInput
  }

  /**
   * LeaveEntry.manager
   */
  export type LeaveEntry$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * LeaveEntry.ceo
   */
  export type LeaveEntry$ceoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * LeaveEntry without action
   */
  export type LeaveEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveEntry
     */
    select?: LeaveEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveEntryInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    port: number | null
  }

  export type DeviceSumAggregateOutputType = {
    port: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    name: string | null
    ipAddress: string | null
    port: number | null
    location: string | null
    status: string | null
    lastConnected: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    name: string | null
    ipAddress: string | null
    port: number | null
    location: string | null
    status: string | null
    lastConnected: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    deviceId: number
    name: number
    ipAddress: number
    port: number
    location: number
    status: number
    lastConnected: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    port?: true
  }

  export type DeviceSumAggregateInputType = {
    port?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    ipAddress?: true
    port?: true
    location?: true
    status?: true
    lastConnected?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    ipAddress?: true
    port?: true
    location?: true
    status?: true
    lastConnected?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    deviceId?: true
    name?: true
    ipAddress?: true
    port?: true
    location?: true
    status?: true
    lastConnected?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    deviceId: string
    name: string
    ipAddress: string | null
    port: number | null
    location: string | null
    status: string
    lastConnected: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    location?: boolean
    status?: boolean
    lastConnected?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceUsers?: boolean | Device$deviceUsersArgs<ExtArgs>
    rawDeviceLogs?: boolean | Device$rawDeviceLogsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    location?: boolean
    status?: boolean
    lastConnected?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    deviceId?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    location?: boolean
    status?: boolean
    lastConnected?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deviceUsers?: boolean | Device$deviceUsersArgs<ExtArgs>
    rawDeviceLogs?: boolean | Device$rawDeviceLogsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      deviceUsers: Prisma.$DeviceUserPayload<ExtArgs>[]
      rawDeviceLogs: Prisma.$RawDeviceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      name: string
      ipAddress: string | null
      port: number | null
      location: string | null
      status: string
      lastConnected: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deviceUsers<T extends Device$deviceUsersArgs<ExtArgs> = {}>(args?: Subset<T, Device$deviceUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findMany"> | Null>
    rawDeviceLogs<T extends Device$rawDeviceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Device$rawDeviceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly deviceId: FieldRef<"Device", 'String'>
    readonly name: FieldRef<"Device", 'String'>
    readonly ipAddress: FieldRef<"Device", 'String'>
    readonly port: FieldRef<"Device", 'Int'>
    readonly location: FieldRef<"Device", 'String'>
    readonly status: FieldRef<"Device", 'String'>
    readonly lastConnected: FieldRef<"Device", 'DateTime'>
    readonly isActive: FieldRef<"Device", 'Boolean'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly updatedAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }

  /**
   * Device.deviceUsers
   */
  export type Device$deviceUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    where?: DeviceUserWhereInput
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    cursor?: DeviceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * Device.rawDeviceLogs
   */
  export type Device$rawDeviceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    where?: RawDeviceLogWhereInput
    orderBy?: RawDeviceLogOrderByWithRelationInput | RawDeviceLogOrderByWithRelationInput[]
    cursor?: RawDeviceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawDeviceLogScalarFieldEnum | RawDeviceLogScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceUser
   */

  export type AggregateDeviceUser = {
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  export type DeviceUserMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    deviceUserId: string | null
    employeeId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceUserMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    deviceUserId: string | null
    employeeId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceUserCountAggregateOutputType = {
    id: number
    deviceId: number
    deviceUserId: number
    employeeId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceUserMinAggregateInputType = {
    id?: true
    deviceId?: true
    deviceUserId?: true
    employeeId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceUserMaxAggregateInputType = {
    id?: true
    deviceId?: true
    deviceUserId?: true
    employeeId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceUserCountAggregateInputType = {
    id?: true
    deviceId?: true
    deviceUserId?: true
    employeeId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceUser to aggregate.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceUsers
    **/
    _count?: true | DeviceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceUserMaxAggregateInputType
  }

  export type GetDeviceUserAggregateType<T extends DeviceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceUser[P]>
      : GetScalarType<T[P], AggregateDeviceUser[P]>
  }




  export type DeviceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceUserWhereInput
    orderBy?: DeviceUserOrderByWithAggregationInput | DeviceUserOrderByWithAggregationInput[]
    by: DeviceUserScalarFieldEnum[] | DeviceUserScalarFieldEnum
    having?: DeviceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceUserCountAggregateInputType | true
    _min?: DeviceUserMinAggregateInputType
    _max?: DeviceUserMaxAggregateInputType
  }

  export type DeviceUserGroupByOutputType = {
    id: string
    deviceId: string
    deviceUserId: string
    employeeId: string | null
    name: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  type GetDeviceUserGroupByPayload<T extends DeviceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
        }
      >
    >


  export type DeviceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    deviceUserId?: boolean
    employeeId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceUser"]>

  export type DeviceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    deviceUserId?: boolean
    employeeId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceUser"]>

  export type DeviceUserSelectScalar = {
    id?: boolean
    deviceId?: boolean
    deviceUserId?: boolean
    employeeId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type DeviceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceUser"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      deviceUserId: string
      employeeId: string | null
      name: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceUser"]>
    composites: {}
  }

  type DeviceUserGetPayload<S extends boolean | null | undefined | DeviceUserDefaultArgs> = $Result.GetResult<Prisma.$DeviceUserPayload, S>

  type DeviceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceUserCountAggregateInputType | true
    }

  export interface DeviceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceUser'], meta: { name: 'DeviceUser' } }
    /**
     * Find zero or one DeviceUser that matches the filter.
     * @param {DeviceUserFindUniqueArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceUserFindUniqueArgs>(args: SelectSubset<T, DeviceUserFindUniqueArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceUserFindUniqueOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceUserFindFirstArgs>(args?: SelectSubset<T, DeviceUserFindFirstArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany()
     * 
     * // Get first 10 DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceUserWithIdOnly = await prisma.deviceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceUserFindManyArgs>(args?: SelectSubset<T, DeviceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceUser.
     * @param {DeviceUserCreateArgs} args - Arguments to create a DeviceUser.
     * @example
     * // Create one DeviceUser
     * const DeviceUser = await prisma.deviceUser.create({
     *   data: {
     *     // ... data to create a DeviceUser
     *   }
     * })
     * 
     */
    create<T extends DeviceUserCreateArgs>(args: SelectSubset<T, DeviceUserCreateArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceUsers.
     * @param {DeviceUserCreateManyArgs} args - Arguments to create many DeviceUsers.
     * @example
     * // Create many DeviceUsers
     * const deviceUser = await prisma.deviceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceUserCreateManyArgs>(args?: SelectSubset<T, DeviceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceUsers and returns the data saved in the database.
     * @param {DeviceUserCreateManyAndReturnArgs} args - Arguments to create many DeviceUsers.
     * @example
     * // Create many DeviceUsers
     * const deviceUser = await prisma.deviceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceUsers and only return the `id`
     * const deviceUserWithIdOnly = await prisma.deviceUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceUser.
     * @param {DeviceUserDeleteArgs} args - Arguments to delete one DeviceUser.
     * @example
     * // Delete one DeviceUser
     * const DeviceUser = await prisma.deviceUser.delete({
     *   where: {
     *     // ... filter to delete one DeviceUser
     *   }
     * })
     * 
     */
    delete<T extends DeviceUserDeleteArgs>(args: SelectSubset<T, DeviceUserDeleteArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceUser.
     * @param {DeviceUserUpdateArgs} args - Arguments to update one DeviceUser.
     * @example
     * // Update one DeviceUser
     * const deviceUser = await prisma.deviceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUserUpdateArgs>(args: SelectSubset<T, DeviceUserUpdateArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceUsers.
     * @param {DeviceUserDeleteManyArgs} args - Arguments to filter DeviceUsers to delete.
     * @example
     * // Delete a few DeviceUsers
     * const { count } = await prisma.deviceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceUserDeleteManyArgs>(args?: SelectSubset<T, DeviceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceUsers
     * const deviceUser = await prisma.deviceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUserUpdateManyArgs>(args: SelectSubset<T, DeviceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceUser.
     * @param {DeviceUserUpsertArgs} args - Arguments to update or create a DeviceUser.
     * @example
     * // Update or create a DeviceUser
     * const deviceUser = await prisma.deviceUser.upsert({
     *   create: {
     *     // ... data to create a DeviceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceUser we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUserUpsertArgs>(args: SelectSubset<T, DeviceUserUpsertArgs<ExtArgs>>): Prisma__DeviceUserClient<$Result.GetResult<Prisma.$DeviceUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserCountArgs} args - Arguments to filter DeviceUsers to count.
     * @example
     * // Count the number of DeviceUsers
     * const count = await prisma.deviceUser.count({
     *   where: {
     *     // ... the filter for the DeviceUsers we want to count
     *   }
     * })
    **/
    count<T extends DeviceUserCountArgs>(
      args?: Subset<T, DeviceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceUserAggregateArgs>(args: Subset<T, DeviceUserAggregateArgs>): Prisma.PrismaPromise<GetDeviceUserAggregateType<T>>

    /**
     * Group by DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceUserGroupByArgs['orderBy'] }
        : { orderBy?: DeviceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceUser model
   */
  readonly fields: DeviceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceUser model
   */ 
  interface DeviceUserFieldRefs {
    readonly id: FieldRef<"DeviceUser", 'String'>
    readonly deviceId: FieldRef<"DeviceUser", 'String'>
    readonly deviceUserId: FieldRef<"DeviceUser", 'String'>
    readonly employeeId: FieldRef<"DeviceUser", 'String'>
    readonly name: FieldRef<"DeviceUser", 'String'>
    readonly createdAt: FieldRef<"DeviceUser", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceUser findUnique
   */
  export type DeviceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser findUniqueOrThrow
   */
  export type DeviceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser findFirst
   */
  export type DeviceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     */
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser findFirstOrThrow
   */
  export type DeviceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUser to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     */
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser findMany
   */
  export type DeviceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter, which DeviceUsers to fetch.
     */
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     */
    orderBy?: DeviceUserOrderByWithRelationInput | DeviceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceUsers.
     */
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     */
    skip?: number
    distinct?: DeviceUserScalarFieldEnum | DeviceUserScalarFieldEnum[]
  }

  /**
   * DeviceUser create
   */
  export type DeviceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceUser.
     */
    data: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
  }

  /**
   * DeviceUser createMany
   */
  export type DeviceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceUsers.
     */
    data: DeviceUserCreateManyInput | DeviceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceUser createManyAndReturn
   */
  export type DeviceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceUsers.
     */
    data: DeviceUserCreateManyInput | DeviceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceUser update
   */
  export type DeviceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceUser.
     */
    data: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
    /**
     * Choose, which DeviceUser to update.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser updateMany
   */
  export type DeviceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceUsers.
     */
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyInput>
    /**
     * Filter which DeviceUsers to update
     */
    where?: DeviceUserWhereInput
  }

  /**
   * DeviceUser upsert
   */
  export type DeviceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceUser to update in case it exists.
     */
    where: DeviceUserWhereUniqueInput
    /**
     * In case the DeviceUser found by the `where` argument doesn't exist, create a new DeviceUser with this data.
     */
    create: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
    /**
     * In case the DeviceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
  }

  /**
   * DeviceUser delete
   */
  export type DeviceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
    /**
     * Filter which DeviceUser to delete.
     */
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser deleteMany
   */
  export type DeviceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceUsers to delete
     */
    where?: DeviceUserWhereInput
  }

  /**
   * DeviceUser without action
   */
  export type DeviceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceUser
     */
    select?: DeviceUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceUserInclude<ExtArgs> | null
  }


  /**
   * Model RawDeviceLog
   */

  export type AggregateRawDeviceLog = {
    _count: RawDeviceLogCountAggregateOutputType | null
    _min: RawDeviceLogMinAggregateOutputType | null
    _max: RawDeviceLogMaxAggregateOutputType | null
  }

  export type RawDeviceLogMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    userId: string | null
    punchTime: Date | null
    punchType: string | null
    isProcessed: boolean | null
    createdAt: Date | null
  }

  export type RawDeviceLogMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    userId: string | null
    punchTime: Date | null
    punchType: string | null
    isProcessed: boolean | null
    createdAt: Date | null
  }

  export type RawDeviceLogCountAggregateOutputType = {
    id: number
    deviceId: number
    userId: number
    punchTime: number
    punchType: number
    isProcessed: number
    createdAt: number
    _all: number
  }


  export type RawDeviceLogMinAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    punchTime?: true
    punchType?: true
    isProcessed?: true
    createdAt?: true
  }

  export type RawDeviceLogMaxAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    punchTime?: true
    punchType?: true
    isProcessed?: true
    createdAt?: true
  }

  export type RawDeviceLogCountAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    punchTime?: true
    punchType?: true
    isProcessed?: true
    createdAt?: true
    _all?: true
  }

  export type RawDeviceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawDeviceLog to aggregate.
     */
    where?: RawDeviceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawDeviceLogs to fetch.
     */
    orderBy?: RawDeviceLogOrderByWithRelationInput | RawDeviceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawDeviceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawDeviceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawDeviceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawDeviceLogs
    **/
    _count?: true | RawDeviceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawDeviceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawDeviceLogMaxAggregateInputType
  }

  export type GetRawDeviceLogAggregateType<T extends RawDeviceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRawDeviceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawDeviceLog[P]>
      : GetScalarType<T[P], AggregateRawDeviceLog[P]>
  }




  export type RawDeviceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawDeviceLogWhereInput
    orderBy?: RawDeviceLogOrderByWithAggregationInput | RawDeviceLogOrderByWithAggregationInput[]
    by: RawDeviceLogScalarFieldEnum[] | RawDeviceLogScalarFieldEnum
    having?: RawDeviceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawDeviceLogCountAggregateInputType | true
    _min?: RawDeviceLogMinAggregateInputType
    _max?: RawDeviceLogMaxAggregateInputType
  }

  export type RawDeviceLogGroupByOutputType = {
    id: string
    deviceId: string
    userId: string
    punchTime: Date
    punchType: string | null
    isProcessed: boolean
    createdAt: Date
    _count: RawDeviceLogCountAggregateOutputType | null
    _min: RawDeviceLogMinAggregateOutputType | null
    _max: RawDeviceLogMaxAggregateOutputType | null
  }

  type GetRawDeviceLogGroupByPayload<T extends RawDeviceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawDeviceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawDeviceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawDeviceLogGroupByOutputType[P]>
            : GetScalarType<T[P], RawDeviceLogGroupByOutputType[P]>
        }
      >
    >


  export type RawDeviceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    punchTime?: boolean
    punchType?: boolean
    isProcessed?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawDeviceLog"]>

  export type RawDeviceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    punchTime?: boolean
    punchType?: boolean
    isProcessed?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rawDeviceLog"]>

  export type RawDeviceLogSelectScalar = {
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    punchTime?: boolean
    punchType?: boolean
    isProcessed?: boolean
    createdAt?: boolean
  }

  export type RawDeviceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type RawDeviceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $RawDeviceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawDeviceLog"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      userId: string
      punchTime: Date
      punchType: string | null
      isProcessed: boolean
      createdAt: Date
    }, ExtArgs["result"]["rawDeviceLog"]>
    composites: {}
  }

  type RawDeviceLogGetPayload<S extends boolean | null | undefined | RawDeviceLogDefaultArgs> = $Result.GetResult<Prisma.$RawDeviceLogPayload, S>

  type RawDeviceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RawDeviceLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RawDeviceLogCountAggregateInputType | true
    }

  export interface RawDeviceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawDeviceLog'], meta: { name: 'RawDeviceLog' } }
    /**
     * Find zero or one RawDeviceLog that matches the filter.
     * @param {RawDeviceLogFindUniqueArgs} args - Arguments to find a RawDeviceLog
     * @example
     * // Get one RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawDeviceLogFindUniqueArgs>(args: SelectSubset<T, RawDeviceLogFindUniqueArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RawDeviceLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RawDeviceLogFindUniqueOrThrowArgs} args - Arguments to find a RawDeviceLog
     * @example
     * // Get one RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawDeviceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RawDeviceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RawDeviceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogFindFirstArgs} args - Arguments to find a RawDeviceLog
     * @example
     * // Get one RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawDeviceLogFindFirstArgs>(args?: SelectSubset<T, RawDeviceLogFindFirstArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RawDeviceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogFindFirstOrThrowArgs} args - Arguments to find a RawDeviceLog
     * @example
     * // Get one RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawDeviceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RawDeviceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RawDeviceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawDeviceLogs
     * const rawDeviceLogs = await prisma.rawDeviceLog.findMany()
     * 
     * // Get first 10 RawDeviceLogs
     * const rawDeviceLogs = await prisma.rawDeviceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rawDeviceLogWithIdOnly = await prisma.rawDeviceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RawDeviceLogFindManyArgs>(args?: SelectSubset<T, RawDeviceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RawDeviceLog.
     * @param {RawDeviceLogCreateArgs} args - Arguments to create a RawDeviceLog.
     * @example
     * // Create one RawDeviceLog
     * const RawDeviceLog = await prisma.rawDeviceLog.create({
     *   data: {
     *     // ... data to create a RawDeviceLog
     *   }
     * })
     * 
     */
    create<T extends RawDeviceLogCreateArgs>(args: SelectSubset<T, RawDeviceLogCreateArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RawDeviceLogs.
     * @param {RawDeviceLogCreateManyArgs} args - Arguments to create many RawDeviceLogs.
     * @example
     * // Create many RawDeviceLogs
     * const rawDeviceLog = await prisma.rawDeviceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawDeviceLogCreateManyArgs>(args?: SelectSubset<T, RawDeviceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawDeviceLogs and returns the data saved in the database.
     * @param {RawDeviceLogCreateManyAndReturnArgs} args - Arguments to create many RawDeviceLogs.
     * @example
     * // Create many RawDeviceLogs
     * const rawDeviceLog = await prisma.rawDeviceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawDeviceLogs and only return the `id`
     * const rawDeviceLogWithIdOnly = await prisma.rawDeviceLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawDeviceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RawDeviceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RawDeviceLog.
     * @param {RawDeviceLogDeleteArgs} args - Arguments to delete one RawDeviceLog.
     * @example
     * // Delete one RawDeviceLog
     * const RawDeviceLog = await prisma.rawDeviceLog.delete({
     *   where: {
     *     // ... filter to delete one RawDeviceLog
     *   }
     * })
     * 
     */
    delete<T extends RawDeviceLogDeleteArgs>(args: SelectSubset<T, RawDeviceLogDeleteArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RawDeviceLog.
     * @param {RawDeviceLogUpdateArgs} args - Arguments to update one RawDeviceLog.
     * @example
     * // Update one RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawDeviceLogUpdateArgs>(args: SelectSubset<T, RawDeviceLogUpdateArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RawDeviceLogs.
     * @param {RawDeviceLogDeleteManyArgs} args - Arguments to filter RawDeviceLogs to delete.
     * @example
     * // Delete a few RawDeviceLogs
     * const { count } = await prisma.rawDeviceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawDeviceLogDeleteManyArgs>(args?: SelectSubset<T, RawDeviceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawDeviceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawDeviceLogs
     * const rawDeviceLog = await prisma.rawDeviceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawDeviceLogUpdateManyArgs>(args: SelectSubset<T, RawDeviceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RawDeviceLog.
     * @param {RawDeviceLogUpsertArgs} args - Arguments to update or create a RawDeviceLog.
     * @example
     * // Update or create a RawDeviceLog
     * const rawDeviceLog = await prisma.rawDeviceLog.upsert({
     *   create: {
     *     // ... data to create a RawDeviceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawDeviceLog we want to update
     *   }
     * })
     */
    upsert<T extends RawDeviceLogUpsertArgs>(args: SelectSubset<T, RawDeviceLogUpsertArgs<ExtArgs>>): Prisma__RawDeviceLogClient<$Result.GetResult<Prisma.$RawDeviceLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RawDeviceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogCountArgs} args - Arguments to filter RawDeviceLogs to count.
     * @example
     * // Count the number of RawDeviceLogs
     * const count = await prisma.rawDeviceLog.count({
     *   where: {
     *     // ... the filter for the RawDeviceLogs we want to count
     *   }
     * })
    **/
    count<T extends RawDeviceLogCountArgs>(
      args?: Subset<T, RawDeviceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawDeviceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawDeviceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawDeviceLogAggregateArgs>(args: Subset<T, RawDeviceLogAggregateArgs>): Prisma.PrismaPromise<GetRawDeviceLogAggregateType<T>>

    /**
     * Group by RawDeviceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawDeviceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawDeviceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawDeviceLogGroupByArgs['orderBy'] }
        : { orderBy?: RawDeviceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawDeviceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawDeviceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawDeviceLog model
   */
  readonly fields: RawDeviceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawDeviceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawDeviceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawDeviceLog model
   */ 
  interface RawDeviceLogFieldRefs {
    readonly id: FieldRef<"RawDeviceLog", 'String'>
    readonly deviceId: FieldRef<"RawDeviceLog", 'String'>
    readonly userId: FieldRef<"RawDeviceLog", 'String'>
    readonly punchTime: FieldRef<"RawDeviceLog", 'DateTime'>
    readonly punchType: FieldRef<"RawDeviceLog", 'String'>
    readonly isProcessed: FieldRef<"RawDeviceLog", 'Boolean'>
    readonly createdAt: FieldRef<"RawDeviceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RawDeviceLog findUnique
   */
  export type RawDeviceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter, which RawDeviceLog to fetch.
     */
    where: RawDeviceLogWhereUniqueInput
  }

  /**
   * RawDeviceLog findUniqueOrThrow
   */
  export type RawDeviceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter, which RawDeviceLog to fetch.
     */
    where: RawDeviceLogWhereUniqueInput
  }

  /**
   * RawDeviceLog findFirst
   */
  export type RawDeviceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter, which RawDeviceLog to fetch.
     */
    where?: RawDeviceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawDeviceLogs to fetch.
     */
    orderBy?: RawDeviceLogOrderByWithRelationInput | RawDeviceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawDeviceLogs.
     */
    cursor?: RawDeviceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawDeviceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawDeviceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawDeviceLogs.
     */
    distinct?: RawDeviceLogScalarFieldEnum | RawDeviceLogScalarFieldEnum[]
  }

  /**
   * RawDeviceLog findFirstOrThrow
   */
  export type RawDeviceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter, which RawDeviceLog to fetch.
     */
    where?: RawDeviceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawDeviceLogs to fetch.
     */
    orderBy?: RawDeviceLogOrderByWithRelationInput | RawDeviceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawDeviceLogs.
     */
    cursor?: RawDeviceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawDeviceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawDeviceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawDeviceLogs.
     */
    distinct?: RawDeviceLogScalarFieldEnum | RawDeviceLogScalarFieldEnum[]
  }

  /**
   * RawDeviceLog findMany
   */
  export type RawDeviceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter, which RawDeviceLogs to fetch.
     */
    where?: RawDeviceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawDeviceLogs to fetch.
     */
    orderBy?: RawDeviceLogOrderByWithRelationInput | RawDeviceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawDeviceLogs.
     */
    cursor?: RawDeviceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawDeviceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawDeviceLogs.
     */
    skip?: number
    distinct?: RawDeviceLogScalarFieldEnum | RawDeviceLogScalarFieldEnum[]
  }

  /**
   * RawDeviceLog create
   */
  export type RawDeviceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RawDeviceLog.
     */
    data: XOR<RawDeviceLogCreateInput, RawDeviceLogUncheckedCreateInput>
  }

  /**
   * RawDeviceLog createMany
   */
  export type RawDeviceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawDeviceLogs.
     */
    data: RawDeviceLogCreateManyInput | RawDeviceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawDeviceLog createManyAndReturn
   */
  export type RawDeviceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RawDeviceLogs.
     */
    data: RawDeviceLogCreateManyInput | RawDeviceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawDeviceLog update
   */
  export type RawDeviceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RawDeviceLog.
     */
    data: XOR<RawDeviceLogUpdateInput, RawDeviceLogUncheckedUpdateInput>
    /**
     * Choose, which RawDeviceLog to update.
     */
    where: RawDeviceLogWhereUniqueInput
  }

  /**
   * RawDeviceLog updateMany
   */
  export type RawDeviceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawDeviceLogs.
     */
    data: XOR<RawDeviceLogUpdateManyMutationInput, RawDeviceLogUncheckedUpdateManyInput>
    /**
     * Filter which RawDeviceLogs to update
     */
    where?: RawDeviceLogWhereInput
  }

  /**
   * RawDeviceLog upsert
   */
  export type RawDeviceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RawDeviceLog to update in case it exists.
     */
    where: RawDeviceLogWhereUniqueInput
    /**
     * In case the RawDeviceLog found by the `where` argument doesn't exist, create a new RawDeviceLog with this data.
     */
    create: XOR<RawDeviceLogCreateInput, RawDeviceLogUncheckedCreateInput>
    /**
     * In case the RawDeviceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawDeviceLogUpdateInput, RawDeviceLogUncheckedUpdateInput>
  }

  /**
   * RawDeviceLog delete
   */
  export type RawDeviceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
    /**
     * Filter which RawDeviceLog to delete.
     */
    where: RawDeviceLogWhereUniqueInput
  }

  /**
   * RawDeviceLog deleteMany
   */
  export type RawDeviceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawDeviceLogs to delete
     */
    where?: RawDeviceLogWhereInput
  }

  /**
   * RawDeviceLog without action
   */
  export type RawDeviceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawDeviceLog
     */
    select?: RawDeviceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawDeviceLogInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceLog
   */

  export type AggregateAttendanceLog = {
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  export type AttendanceLogAvgAggregateOutputType = {
    workingHours: number | null
    lateArrival: number | null
    earlyDeparture: number | null
    totalPunches: number | null
  }

  export type AttendanceLogSumAggregateOutputType = {
    workingHours: number | null
    lateArrival: number | null
    earlyDeparture: number | null
    totalPunches: number | null
  }

  export type AttendanceLogMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    firstIn: Date | null
    lastOut: Date | null
    workingHours: number | null
    shiftStart: Date | null
    shiftEnd: Date | null
    lateArrival: number | null
    earlyDeparture: number | null
    status: string | null
    totalPunches: number | null
    rawData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceLogMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    firstIn: Date | null
    lastOut: Date | null
    workingHours: number | null
    shiftStart: Date | null
    shiftEnd: Date | null
    lateArrival: number | null
    earlyDeparture: number | null
    status: string | null
    totalPunches: number | null
    rawData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceLogCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    firstIn: number
    lastOut: number
    workingHours: number
    shiftStart: number
    shiftEnd: number
    lateArrival: number
    earlyDeparture: number
    status: number
    totalPunches: number
    rawData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceLogAvgAggregateInputType = {
    workingHours?: true
    lateArrival?: true
    earlyDeparture?: true
    totalPunches?: true
  }

  export type AttendanceLogSumAggregateInputType = {
    workingHours?: true
    lateArrival?: true
    earlyDeparture?: true
    totalPunches?: true
  }

  export type AttendanceLogMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    firstIn?: true
    lastOut?: true
    workingHours?: true
    shiftStart?: true
    shiftEnd?: true
    lateArrival?: true
    earlyDeparture?: true
    status?: true
    totalPunches?: true
    rawData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceLogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    firstIn?: true
    lastOut?: true
    workingHours?: true
    shiftStart?: true
    shiftEnd?: true
    lateArrival?: true
    earlyDeparture?: true
    status?: true
    totalPunches?: true
    rawData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceLogCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    firstIn?: true
    lastOut?: true
    workingHours?: true
    shiftStart?: true
    shiftEnd?: true
    lateArrival?: true
    earlyDeparture?: true
    status?: true
    totalPunches?: true
    rawData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLog to aggregate.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceLogs
    **/
    _count?: true | AttendanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type GetAttendanceLogAggregateType<T extends AttendanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceLog[P]>
      : GetScalarType<T[P], AggregateAttendanceLog[P]>
  }




  export type AttendanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithAggregationInput | AttendanceLogOrderByWithAggregationInput[]
    by: AttendanceLogScalarFieldEnum[] | AttendanceLogScalarFieldEnum
    having?: AttendanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceLogCountAggregateInputType | true
    _avg?: AttendanceLogAvgAggregateInputType
    _sum?: AttendanceLogSumAggregateInputType
    _min?: AttendanceLogMinAggregateInputType
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type AttendanceLogGroupByOutputType = {
    id: string
    employeeId: string
    date: Date
    firstIn: Date | null
    lastOut: Date | null
    workingHours: number | null
    shiftStart: Date | null
    shiftEnd: Date | null
    lateArrival: number
    earlyDeparture: number
    status: string
    totalPunches: number
    rawData: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  type GetAttendanceLogGroupByPayload<T extends AttendanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workingHours?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    status?: boolean
    totalPunches?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workingHours?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    status?: boolean
    totalPunches?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    firstIn?: boolean
    lastOut?: boolean
    workingHours?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    status?: boolean
    totalPunches?: boolean
    rawData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AttendanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceLog"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      date: Date
      firstIn: Date | null
      lastOut: Date | null
      workingHours: number | null
      shiftStart: Date | null
      shiftEnd: Date | null
      lateArrival: number
      earlyDeparture: number
      status: string
      totalPunches: number
      rawData: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceLog"]>
    composites: {}
  }

  type AttendanceLogGetPayload<S extends boolean | null | undefined | AttendanceLogDefaultArgs> = $Result.GetResult<Prisma.$AttendanceLogPayload, S>

  type AttendanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceLogCountAggregateInputType | true
    }

  export interface AttendanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceLog'], meta: { name: 'AttendanceLog' } }
    /**
     * Find zero or one AttendanceLog that matches the filter.
     * @param {AttendanceLogFindUniqueArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceLogFindUniqueArgs>(args: SelectSubset<T, AttendanceLogFindUniqueArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendanceLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceLogFindUniqueOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceLogFindFirstArgs>(args?: SelectSubset<T, AttendanceLogFindFirstArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany()
     * 
     * // Get first 10 AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceLogFindManyArgs>(args?: SelectSubset<T, AttendanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendanceLog.
     * @param {AttendanceLogCreateArgs} args - Arguments to create a AttendanceLog.
     * @example
     * // Create one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.create({
     *   data: {
     *     // ... data to create a AttendanceLog
     *   }
     * })
     * 
     */
    create<T extends AttendanceLogCreateArgs>(args: SelectSubset<T, AttendanceLogCreateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendanceLogs.
     * @param {AttendanceLogCreateManyArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceLogCreateManyArgs>(args?: SelectSubset<T, AttendanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceLogs and returns the data saved in the database.
     * @param {AttendanceLogCreateManyAndReturnArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceLogs and only return the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendanceLog.
     * @param {AttendanceLogDeleteArgs} args - Arguments to delete one AttendanceLog.
     * @example
     * // Delete one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.delete({
     *   where: {
     *     // ... filter to delete one AttendanceLog
     *   }
     * })
     * 
     */
    delete<T extends AttendanceLogDeleteArgs>(args: SelectSubset<T, AttendanceLogDeleteArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendanceLog.
     * @param {AttendanceLogUpdateArgs} args - Arguments to update one AttendanceLog.
     * @example
     * // Update one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceLogUpdateArgs>(args: SelectSubset<T, AttendanceLogUpdateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendanceLogs.
     * @param {AttendanceLogDeleteManyArgs} args - Arguments to filter AttendanceLogs to delete.
     * @example
     * // Delete a few AttendanceLogs
     * const { count } = await prisma.attendanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceLogDeleteManyArgs>(args?: SelectSubset<T, AttendanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceLogUpdateManyArgs>(args: SelectSubset<T, AttendanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceLog.
     * @param {AttendanceLogUpsertArgs} args - Arguments to update or create a AttendanceLog.
     * @example
     * // Update or create a AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.upsert({
     *   create: {
     *     // ... data to create a AttendanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceLog we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceLogUpsertArgs>(args: SelectSubset<T, AttendanceLogUpsertArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogCountArgs} args - Arguments to filter AttendanceLogs to count.
     * @example
     * // Count the number of AttendanceLogs
     * const count = await prisma.attendanceLog.count({
     *   where: {
     *     // ... the filter for the AttendanceLogs we want to count
     *   }
     * })
    **/
    count<T extends AttendanceLogCountArgs>(
      args?: Subset<T, AttendanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceLogAggregateArgs>(args: Subset<T, AttendanceLogAggregateArgs>): Prisma.PrismaPromise<GetAttendanceLogAggregateType<T>>

    /**
     * Group by AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceLogGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceLog model
   */
  readonly fields: AttendanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceLog model
   */ 
  interface AttendanceLogFieldRefs {
    readonly id: FieldRef<"AttendanceLog", 'String'>
    readonly employeeId: FieldRef<"AttendanceLog", 'String'>
    readonly date: FieldRef<"AttendanceLog", 'DateTime'>
    readonly firstIn: FieldRef<"AttendanceLog", 'DateTime'>
    readonly lastOut: FieldRef<"AttendanceLog", 'DateTime'>
    readonly workingHours: FieldRef<"AttendanceLog", 'Float'>
    readonly shiftStart: FieldRef<"AttendanceLog", 'DateTime'>
    readonly shiftEnd: FieldRef<"AttendanceLog", 'DateTime'>
    readonly lateArrival: FieldRef<"AttendanceLog", 'Int'>
    readonly earlyDeparture: FieldRef<"AttendanceLog", 'Int'>
    readonly status: FieldRef<"AttendanceLog", 'String'>
    readonly totalPunches: FieldRef<"AttendanceLog", 'Int'>
    readonly rawData: FieldRef<"AttendanceLog", 'String'>
    readonly createdAt: FieldRef<"AttendanceLog", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceLog findUnique
   */
  export type AttendanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findUniqueOrThrow
   */
  export type AttendanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findFirst
   */
  export type AttendanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findFirstOrThrow
   */
  export type AttendanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findMany
   */
  export type AttendanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLogs to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog create
   */
  export type AttendanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceLog.
     */
    data: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
  }

  /**
   * AttendanceLog createMany
   */
  export type AttendanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceLog createManyAndReturn
   */
  export type AttendanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceLog update
   */
  export type AttendanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceLog.
     */
    data: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
    /**
     * Choose, which AttendanceLog to update.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog updateMany
   */
  export type AttendanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceLogs.
     */
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceLogs to update
     */
    where?: AttendanceLogWhereInput
  }

  /**
   * AttendanceLog upsert
   */
  export type AttendanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceLog to update in case it exists.
     */
    where: AttendanceLogWhereUniqueInput
    /**
     * In case the AttendanceLog found by the `where` argument doesn't exist, create a new AttendanceLog with this data.
     */
    create: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
    /**
     * In case the AttendanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
  }

  /**
   * AttendanceLog delete
   */
  export type AttendanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter which AttendanceLog to delete.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog deleteMany
   */
  export type AttendanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLogs to delete
     */
    where?: AttendanceLogWhereInput
  }

  /**
   * AttendanceLog without action
   */
  export type AttendanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
  }


  /**
   * Model SyncStatus
   */

  export type AggregateSyncStatus = {
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  export type SyncStatusAvgAggregateOutputType = {
    recordsSynced: number | null
  }

  export type SyncStatusSumAggregateOutputType = {
    recordsSynced: number | null
  }

  export type SyncStatusMinAggregateOutputType = {
    id: string | null
    lastSyncTime: Date | null
    recordsSynced: number | null
    status: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SyncStatusMaxAggregateOutputType = {
    id: string | null
    lastSyncTime: Date | null
    recordsSynced: number | null
    status: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SyncStatusCountAggregateOutputType = {
    id: number
    lastSyncTime: number
    recordsSynced: number
    status: number
    message: number
    createdAt: number
    _all: number
  }


  export type SyncStatusAvgAggregateInputType = {
    recordsSynced?: true
  }

  export type SyncStatusSumAggregateInputType = {
    recordsSynced?: true
  }

  export type SyncStatusMinAggregateInputType = {
    id?: true
    lastSyncTime?: true
    recordsSynced?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type SyncStatusMaxAggregateInputType = {
    id?: true
    lastSyncTime?: true
    recordsSynced?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type SyncStatusCountAggregateInputType = {
    id?: true
    lastSyncTime?: true
    recordsSynced?: true
    status?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type SyncStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatus to aggregate.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncStatuses
    **/
    _count?: true | SyncStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncStatusMaxAggregateInputType
  }

  export type GetSyncStatusAggregateType<T extends SyncStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncStatus[P]>
      : GetScalarType<T[P], AggregateSyncStatus[P]>
  }




  export type SyncStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncStatusWhereInput
    orderBy?: SyncStatusOrderByWithAggregationInput | SyncStatusOrderByWithAggregationInput[]
    by: SyncStatusScalarFieldEnum[] | SyncStatusScalarFieldEnum
    having?: SyncStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncStatusCountAggregateInputType | true
    _avg?: SyncStatusAvgAggregateInputType
    _sum?: SyncStatusSumAggregateInputType
    _min?: SyncStatusMinAggregateInputType
    _max?: SyncStatusMaxAggregateInputType
  }

  export type SyncStatusGroupByOutputType = {
    id: string
    lastSyncTime: Date
    recordsSynced: number
    status: string
    message: string | null
    createdAt: Date
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  type GetSyncStatusGroupByPayload<T extends SyncStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
        }
      >
    >


  export type SyncStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSyncTime?: boolean
    recordsSynced?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSyncTime?: boolean
    recordsSynced?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectScalar = {
    id?: boolean
    lastSyncTime?: boolean
    recordsSynced?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }


  export type $SyncStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lastSyncTime: Date
      recordsSynced: number
      status: string
      message: string | null
      createdAt: Date
    }, ExtArgs["result"]["syncStatus"]>
    composites: {}
  }

  type SyncStatusGetPayload<S extends boolean | null | undefined | SyncStatusDefaultArgs> = $Result.GetResult<Prisma.$SyncStatusPayload, S>

  type SyncStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncStatusCountAggregateInputType | true
    }

  export interface SyncStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncStatus'], meta: { name: 'SyncStatus' } }
    /**
     * Find zero or one SyncStatus that matches the filter.
     * @param {SyncStatusFindUniqueArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncStatusFindUniqueArgs>(args: SelectSubset<T, SyncStatusFindUniqueArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncStatusFindUniqueOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncStatusFindFirstArgs>(args?: SelectSubset<T, SyncStatusFindFirstArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany()
     * 
     * // Get first 10 SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncStatusFindManyArgs>(args?: SelectSubset<T, SyncStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncStatus.
     * @param {SyncStatusCreateArgs} args - Arguments to create a SyncStatus.
     * @example
     * // Create one SyncStatus
     * const SyncStatus = await prisma.syncStatus.create({
     *   data: {
     *     // ... data to create a SyncStatus
     *   }
     * })
     * 
     */
    create<T extends SyncStatusCreateArgs>(args: SelectSubset<T, SyncStatusCreateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncStatuses.
     * @param {SyncStatusCreateManyArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncStatusCreateManyArgs>(args?: SelectSubset<T, SyncStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncStatuses and returns the data saved in the database.
     * @param {SyncStatusCreateManyAndReturnArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncStatuses and only return the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncStatus.
     * @param {SyncStatusDeleteArgs} args - Arguments to delete one SyncStatus.
     * @example
     * // Delete one SyncStatus
     * const SyncStatus = await prisma.syncStatus.delete({
     *   where: {
     *     // ... filter to delete one SyncStatus
     *   }
     * })
     * 
     */
    delete<T extends SyncStatusDeleteArgs>(args: SelectSubset<T, SyncStatusDeleteArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncStatus.
     * @param {SyncStatusUpdateArgs} args - Arguments to update one SyncStatus.
     * @example
     * // Update one SyncStatus
     * const syncStatus = await prisma.syncStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncStatusUpdateArgs>(args: SelectSubset<T, SyncStatusUpdateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncStatuses.
     * @param {SyncStatusDeleteManyArgs} args - Arguments to filter SyncStatuses to delete.
     * @example
     * // Delete a few SyncStatuses
     * const { count } = await prisma.syncStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncStatusDeleteManyArgs>(args?: SelectSubset<T, SyncStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncStatuses
     * const syncStatus = await prisma.syncStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncStatusUpdateManyArgs>(args: SelectSubset<T, SyncStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncStatus.
     * @param {SyncStatusUpsertArgs} args - Arguments to update or create a SyncStatus.
     * @example
     * // Update or create a SyncStatus
     * const syncStatus = await prisma.syncStatus.upsert({
     *   create: {
     *     // ... data to create a SyncStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncStatus we want to update
     *   }
     * })
     */
    upsert<T extends SyncStatusUpsertArgs>(args: SelectSubset<T, SyncStatusUpsertArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusCountArgs} args - Arguments to filter SyncStatuses to count.
     * @example
     * // Count the number of SyncStatuses
     * const count = await prisma.syncStatus.count({
     *   where: {
     *     // ... the filter for the SyncStatuses we want to count
     *   }
     * })
    **/
    count<T extends SyncStatusCountArgs>(
      args?: Subset<T, SyncStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncStatusAggregateArgs>(args: Subset<T, SyncStatusAggregateArgs>): Prisma.PrismaPromise<GetSyncStatusAggregateType<T>>

    /**
     * Group by SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncStatusGroupByArgs['orderBy'] }
        : { orderBy?: SyncStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncStatus model
   */
  readonly fields: SyncStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncStatus model
   */ 
  interface SyncStatusFieldRefs {
    readonly id: FieldRef<"SyncStatus", 'String'>
    readonly lastSyncTime: FieldRef<"SyncStatus", 'DateTime'>
    readonly recordsSynced: FieldRef<"SyncStatus", 'Int'>
    readonly status: FieldRef<"SyncStatus", 'String'>
    readonly message: FieldRef<"SyncStatus", 'String'>
    readonly createdAt: FieldRef<"SyncStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncStatus findUnique
   */
  export type SyncStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findUniqueOrThrow
   */
  export type SyncStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findFirst
   */
  export type SyncStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findFirstOrThrow
   */
  export type SyncStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findMany
   */
  export type SyncStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatuses to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus create
   */
  export type SyncStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncStatus.
     */
    data: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
  }

  /**
   * SyncStatus createMany
   */
  export type SyncStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncStatus createManyAndReturn
   */
  export type SyncStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncStatus update
   */
  export type SyncStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncStatus.
     */
    data: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
    /**
     * Choose, which SyncStatus to update.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus updateMany
   */
  export type SyncStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncStatuses.
     */
    data: XOR<SyncStatusUpdateManyMutationInput, SyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which SyncStatuses to update
     */
    where?: SyncStatusWhereInput
  }

  /**
   * SyncStatus upsert
   */
  export type SyncStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncStatus to update in case it exists.
     */
    where: SyncStatusWhereUniqueInput
    /**
     * In case the SyncStatus found by the `where` argument doesn't exist, create a new SyncStatus with this data.
     */
    create: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
    /**
     * In case the SyncStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
  }

  /**
   * SyncStatus delete
   */
  export type SyncStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter which SyncStatus to delete.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus deleteMany
   */
  export type SyncStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatuses to delete
     */
    where?: SyncStatusWhereInput
  }

  /**
   * SyncStatus without action
   */
  export type SyncStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string | null
      oldValue: string | null
      newValue: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    month: number | null
    year: number | null
    totalWorkingDays: number | null
    actualPresentDays: number | null
    lopDays: number | null
    paidDays: number | null
    basicPaid: number | null
    hraPaid: number | null
    conveyancePaid: number | null
    medicalPaid: number | null
    specialPaid: number | null
    allowancesPaid: number | null
    bonus: number | null
    incentives: number | null
    arrears: number | null
    otHours: number | null
    otPay: number | null
    pfDeduction: number | null
    esiDeduction: number | null
    ptDeduction: number | null
    tdsDeduction: number | null
    otherDeductions: number | null
    employerPF: number | null
    employerESI: number | null
    grossSalary: number | null
    totalDeductions: number | null
    netSalary: number | null
  }

  export type PayrollSumAggregateOutputType = {
    month: number | null
    year: number | null
    totalWorkingDays: number | null
    actualPresentDays: number | null
    lopDays: number | null
    paidDays: number | null
    basicPaid: number | null
    hraPaid: number | null
    conveyancePaid: number | null
    medicalPaid: number | null
    specialPaid: number | null
    allowancesPaid: number | null
    bonus: number | null
    incentives: number | null
    arrears: number | null
    otHours: number | null
    otPay: number | null
    pfDeduction: number | null
    esiDeduction: number | null
    ptDeduction: number | null
    tdsDeduction: number | null
    otherDeductions: number | null
    employerPF: number | null
    employerESI: number | null
    grossSalary: number | null
    totalDeductions: number | null
    netSalary: number | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    month: number | null
    year: number | null
    totalWorkingDays: number | null
    actualPresentDays: number | null
    lopDays: number | null
    paidDays: number | null
    basicPaid: number | null
    hraPaid: number | null
    conveyancePaid: number | null
    medicalPaid: number | null
    specialPaid: number | null
    allowancesPaid: number | null
    bonus: number | null
    incentives: number | null
    arrears: number | null
    otHours: number | null
    otPay: number | null
    pfDeduction: number | null
    esiDeduction: number | null
    ptDeduction: number | null
    tdsDeduction: number | null
    otherDeductions: number | null
    employerPF: number | null
    employerESI: number | null
    grossSalary: number | null
    totalDeductions: number | null
    netSalary: number | null
    status: string | null
    remarks: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    month: number | null
    year: number | null
    totalWorkingDays: number | null
    actualPresentDays: number | null
    lopDays: number | null
    paidDays: number | null
    basicPaid: number | null
    hraPaid: number | null
    conveyancePaid: number | null
    medicalPaid: number | null
    specialPaid: number | null
    allowancesPaid: number | null
    bonus: number | null
    incentives: number | null
    arrears: number | null
    otHours: number | null
    otPay: number | null
    pfDeduction: number | null
    esiDeduction: number | null
    ptDeduction: number | null
    tdsDeduction: number | null
    otherDeductions: number | null
    employerPF: number | null
    employerESI: number | null
    grossSalary: number | null
    totalDeductions: number | null
    netSalary: number | null
    status: string | null
    remarks: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    employeeId: number
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid: number
    medicalPaid: number
    specialPaid: number
    allowancesPaid: number
    bonus: number
    incentives: number
    arrears: number
    otHours: number
    otPay: number
    pfDeduction: number
    esiDeduction: number
    ptDeduction: number
    tdsDeduction: number
    otherDeductions: number
    employerPF: number
    employerESI: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status: number
    remarks: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    month?: true
    year?: true
    totalWorkingDays?: true
    actualPresentDays?: true
    lopDays?: true
    paidDays?: true
    basicPaid?: true
    hraPaid?: true
    conveyancePaid?: true
    medicalPaid?: true
    specialPaid?: true
    allowancesPaid?: true
    bonus?: true
    incentives?: true
    arrears?: true
    otHours?: true
    otPay?: true
    pfDeduction?: true
    esiDeduction?: true
    ptDeduction?: true
    tdsDeduction?: true
    otherDeductions?: true
    employerPF?: true
    employerESI?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type PayrollSumAggregateInputType = {
    month?: true
    year?: true
    totalWorkingDays?: true
    actualPresentDays?: true
    lopDays?: true
    paidDays?: true
    basicPaid?: true
    hraPaid?: true
    conveyancePaid?: true
    medicalPaid?: true
    specialPaid?: true
    allowancesPaid?: true
    bonus?: true
    incentives?: true
    arrears?: true
    otHours?: true
    otPay?: true
    pfDeduction?: true
    esiDeduction?: true
    ptDeduction?: true
    tdsDeduction?: true
    otherDeductions?: true
    employerPF?: true
    employerESI?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    year?: true
    totalWorkingDays?: true
    actualPresentDays?: true
    lopDays?: true
    paidDays?: true
    basicPaid?: true
    hraPaid?: true
    conveyancePaid?: true
    medicalPaid?: true
    specialPaid?: true
    allowancesPaid?: true
    bonus?: true
    incentives?: true
    arrears?: true
    otHours?: true
    otPay?: true
    pfDeduction?: true
    esiDeduction?: true
    ptDeduction?: true
    tdsDeduction?: true
    otherDeductions?: true
    employerPF?: true
    employerESI?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    remarks?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    year?: true
    totalWorkingDays?: true
    actualPresentDays?: true
    lopDays?: true
    paidDays?: true
    basicPaid?: true
    hraPaid?: true
    conveyancePaid?: true
    medicalPaid?: true
    specialPaid?: true
    allowancesPaid?: true
    bonus?: true
    incentives?: true
    arrears?: true
    otHours?: true
    otPay?: true
    pfDeduction?: true
    esiDeduction?: true
    ptDeduction?: true
    tdsDeduction?: true
    otherDeductions?: true
    employerPF?: true
    employerESI?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    remarks?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    year?: true
    totalWorkingDays?: true
    actualPresentDays?: true
    lopDays?: true
    paidDays?: true
    basicPaid?: true
    hraPaid?: true
    conveyancePaid?: true
    medicalPaid?: true
    specialPaid?: true
    allowancesPaid?: true
    bonus?: true
    incentives?: true
    arrears?: true
    otHours?: true
    otPay?: true
    pfDeduction?: true
    esiDeduction?: true
    ptDeduction?: true
    tdsDeduction?: true
    otherDeductions?: true
    employerPF?: true
    employerESI?: true
    grossSalary?: true
    totalDeductions?: true
    netSalary?: true
    status?: true
    remarks?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    employeeId: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid: number
    medicalPaid: number
    specialPaid: number
    allowancesPaid: number
    bonus: number
    incentives: number
    arrears: number
    otHours: number
    otPay: number
    pfDeduction: number
    esiDeduction: number
    ptDeduction: number
    tdsDeduction: number
    otherDeductions: number
    employerPF: number
    employerESI: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status: string
    remarks: string | null
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    totalWorkingDays?: boolean
    actualPresentDays?: boolean
    lopDays?: boolean
    paidDays?: boolean
    basicPaid?: boolean
    hraPaid?: boolean
    conveyancePaid?: boolean
    medicalPaid?: boolean
    specialPaid?: boolean
    allowancesPaid?: boolean
    bonus?: boolean
    incentives?: boolean
    arrears?: boolean
    otHours?: boolean
    otPay?: boolean
    pfDeduction?: boolean
    esiDeduction?: boolean
    ptDeduction?: boolean
    tdsDeduction?: boolean
    otherDeductions?: boolean
    employerPF?: boolean
    employerESI?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    remarks?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    totalWorkingDays?: boolean
    actualPresentDays?: boolean
    lopDays?: boolean
    paidDays?: boolean
    basicPaid?: boolean
    hraPaid?: boolean
    conveyancePaid?: boolean
    medicalPaid?: boolean
    specialPaid?: boolean
    allowancesPaid?: boolean
    bonus?: boolean
    incentives?: boolean
    arrears?: boolean
    otHours?: boolean
    otPay?: boolean
    pfDeduction?: boolean
    esiDeduction?: boolean
    ptDeduction?: boolean
    tdsDeduction?: boolean
    otherDeductions?: boolean
    employerPF?: boolean
    employerESI?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    remarks?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    totalWorkingDays?: boolean
    actualPresentDays?: boolean
    lopDays?: boolean
    paidDays?: boolean
    basicPaid?: boolean
    hraPaid?: boolean
    conveyancePaid?: boolean
    medicalPaid?: boolean
    specialPaid?: boolean
    allowancesPaid?: boolean
    bonus?: boolean
    incentives?: boolean
    arrears?: boolean
    otHours?: boolean
    otPay?: boolean
    pfDeduction?: boolean
    esiDeduction?: boolean
    ptDeduction?: boolean
    tdsDeduction?: boolean
    otherDeductions?: boolean
    employerPF?: boolean
    employerESI?: boolean
    grossSalary?: boolean
    totalDeductions?: boolean
    netSalary?: boolean
    status?: boolean
    remarks?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      month: number
      year: number
      totalWorkingDays: number
      actualPresentDays: number
      lopDays: number
      paidDays: number
      basicPaid: number
      hraPaid: number
      conveyancePaid: number
      medicalPaid: number
      specialPaid: number
      allowancesPaid: number
      bonus: number
      incentives: number
      arrears: number
      otHours: number
      otPay: number
      pfDeduction: number
      esiDeduction: number
      ptDeduction: number
      tdsDeduction: number
      otherDeductions: number
      employerPF: number
      employerESI: number
      grossSalary: number
      totalDeductions: number
      netSalary: number
      status: string
      remarks: string | null
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */ 
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly employeeId: FieldRef<"Payroll", 'String'>
    readonly month: FieldRef<"Payroll", 'Int'>
    readonly year: FieldRef<"Payroll", 'Int'>
    readonly totalWorkingDays: FieldRef<"Payroll", 'Int'>
    readonly actualPresentDays: FieldRef<"Payroll", 'Float'>
    readonly lopDays: FieldRef<"Payroll", 'Float'>
    readonly paidDays: FieldRef<"Payroll", 'Float'>
    readonly basicPaid: FieldRef<"Payroll", 'Float'>
    readonly hraPaid: FieldRef<"Payroll", 'Float'>
    readonly conveyancePaid: FieldRef<"Payroll", 'Float'>
    readonly medicalPaid: FieldRef<"Payroll", 'Float'>
    readonly specialPaid: FieldRef<"Payroll", 'Float'>
    readonly allowancesPaid: FieldRef<"Payroll", 'Float'>
    readonly bonus: FieldRef<"Payroll", 'Float'>
    readonly incentives: FieldRef<"Payroll", 'Float'>
    readonly arrears: FieldRef<"Payroll", 'Float'>
    readonly otHours: FieldRef<"Payroll", 'Float'>
    readonly otPay: FieldRef<"Payroll", 'Float'>
    readonly pfDeduction: FieldRef<"Payroll", 'Float'>
    readonly esiDeduction: FieldRef<"Payroll", 'Float'>
    readonly ptDeduction: FieldRef<"Payroll", 'Float'>
    readonly tdsDeduction: FieldRef<"Payroll", 'Float'>
    readonly otherDeductions: FieldRef<"Payroll", 'Float'>
    readonly employerPF: FieldRef<"Payroll", 'Float'>
    readonly employerESI: FieldRef<"Payroll", 'Float'>
    readonly grossSalary: FieldRef<"Payroll", 'Float'>
    readonly totalDeductions: FieldRef<"Payroll", 'Float'>
    readonly netSalary: FieldRef<"Payroll", 'Float'>
    readonly status: FieldRef<"Payroll", 'String'>
    readonly remarks: FieldRef<"Payroll", 'String'>
    readonly paidAt: FieldRef<"Payroll", 'DateTime'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role: 'role',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    zipCode: 'zipCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    locationId: 'locationId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    branchId: 'branchId',
    managerId: 'managerId',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DesignationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignationScalarFieldEnum = (typeof DesignationScalarFieldEnum)[keyof typeof DesignationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeCode: 'employeeCode',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    branchId: 'branchId',
    departmentId: 'departmentId',
    designationId: 'designationId',
    categoryId: 'categoryId',
    shiftId: 'shiftId',
    deviceUserId: 'deviceUserId',
    sourceEmployeeId: 'sourceEmployeeId',
    dateOfJoining: 'dateOfJoining',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    basicSalary: 'basicSalary',
    hra: 'hra',
    conveyance: 'conveyance',
    medicalAllowance: 'medicalAllowance',
    specialAllowance: 'specialAllowance',
    otherAllowances: 'otherAllowances',
    standardDeductions: 'standardDeductions',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    ifscCode: 'ifscCode',
    panNumber: 'panNumber',
    aadhaarNumber: 'aadhaarNumber',
    isPFEnabled: 'isPFEnabled',
    isESIEnabled: 'isESIEnabled',
    isPTEnabled: 'isPTEnabled',
    isOTEnabled: 'isOTEnabled',
    otRateMultiplier: 'otRateMultiplier'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const CompanyProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    address: 'address',
    logo: 'logo',
    gstin: 'gstin',
    pan: 'pan',
    pfCode: 'pfCode',
    esiCode: 'esiCode',
    tan: 'tan',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    ifscCode: 'ifscCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyProfileScalarFieldEnum = (typeof CompanyProfileScalarFieldEnum)[keyof typeof CompanyProfileScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    gracePeriodIn: 'gracePeriodIn',
    gracePeriodOut: 'gracePeriodOut',
    isNightShift: 'isNightShift',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const EmployeeShiftScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeShiftScalarFieldEnum = (typeof EmployeeShiftScalarFieldEnum)[keyof typeof EmployeeShiftScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    description: 'description',
    isRecurring: 'isRecurring',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const LeaveTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isPaid: 'isPaid',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


  export const LeaveEntryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveTypeId: 'leaveTypeId',
    startDate: 'startDate',
    endDate: 'endDate',
    days: 'days',
    reason: 'reason',
    status: 'status',
    managerApproval: 'managerApproval',
    managerApprovedAt: 'managerApprovedAt',
    managerId: 'managerId',
    ceoApproval: 'ceoApproval',
    ceoApprovedAt: 'ceoApprovedAt',
    ceoId: 'ceoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveEntryScalarFieldEnum = (typeof LeaveEntryScalarFieldEnum)[keyof typeof LeaveEntryScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    name: 'name',
    ipAddress: 'ipAddress',
    port: 'port',
    location: 'location',
    status: 'status',
    lastConnected: 'lastConnected',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceUserScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    deviceUserId: 'deviceUserId',
    employeeId: 'employeeId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceUserScalarFieldEnum = (typeof DeviceUserScalarFieldEnum)[keyof typeof DeviceUserScalarFieldEnum]


  export const RawDeviceLogScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    userId: 'userId',
    punchTime: 'punchTime',
    punchType: 'punchType',
    isProcessed: 'isProcessed',
    createdAt: 'createdAt'
  };

  export type RawDeviceLogScalarFieldEnum = (typeof RawDeviceLogScalarFieldEnum)[keyof typeof RawDeviceLogScalarFieldEnum]


  export const AttendanceLogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    firstIn: 'firstIn',
    lastOut: 'lastOut',
    workingHours: 'workingHours',
    shiftStart: 'shiftStart',
    shiftEnd: 'shiftEnd',
    lateArrival: 'lateArrival',
    earlyDeparture: 'earlyDeparture',
    status: 'status',
    totalPunches: 'totalPunches',
    rawData: 'rawData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceLogScalarFieldEnum = (typeof AttendanceLogScalarFieldEnum)[keyof typeof AttendanceLogScalarFieldEnum]


  export const SyncStatusScalarFieldEnum: {
    id: 'id',
    lastSyncTime: 'lastSyncTime',
    recordsSynced: 'recordsSynced',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type SyncStatusScalarFieldEnum = (typeof SyncStatusScalarFieldEnum)[keyof typeof SyncStatusScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    month: 'month',
    year: 'year',
    totalWorkingDays: 'totalWorkingDays',
    actualPresentDays: 'actualPresentDays',
    lopDays: 'lopDays',
    paidDays: 'paidDays',
    basicPaid: 'basicPaid',
    hraPaid: 'hraPaid',
    conveyancePaid: 'conveyancePaid',
    medicalPaid: 'medicalPaid',
    specialPaid: 'specialPaid',
    allowancesPaid: 'allowancesPaid',
    bonus: 'bonus',
    incentives: 'incentives',
    arrears: 'arrears',
    otHours: 'otHours',
    otPay: 'otPay',
    pfDeduction: 'pfDeduction',
    esiDeduction: 'esiDeduction',
    ptDeduction: 'ptDeduction',
    tdsDeduction: 'tdsDeduction',
    otherDeductions: 'otherDeductions',
    employerPF: 'employerPF',
    employerESI: 'employerESI',
    grossSalary: 'grossSalary',
    totalDeductions: 'totalDeductions',
    netSalary: 'netSalary',
    status: 'status',
    remarks: 'remarks',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    employeeId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }, "id" | "username" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    employeeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    branches?: BranchListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branches?: BranchOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    branches?: BranchListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    state?: StringNullableWithAggregatesFilter<"Location"> | string | null
    country?: StringNullableWithAggregatesFilter<"Location"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    locationId?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    employees?: EmployeeListRelationFilter
    departments?: DepartmentListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    locationId?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    employees?: EmployeeListRelationFilter
    departments?: DepartmentListRelationFilter
  }, "id" | "code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    locationId?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    isActive?: BoolWithAggregatesFilter<"Branch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    branchId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    manager?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    employees?: EmployeeListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    manager?: EmployeeOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code_branchId?: DepartmentCodeBranchIdCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    branchId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    manager?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    employees?: EmployeeListRelationFilter
  }, "id" | "code_branchId">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringWithAggregatesFilter<"Department"> | string
    branchId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type DesignationWhereInput = {
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    id?: StringFilter<"Designation"> | string
    name?: StringFilter<"Designation"> | string
    code?: StringFilter<"Designation"> | string
    description?: StringNullableFilter<"Designation"> | string | null
    isActive?: BoolFilter<"Designation"> | boolean
    createdAt?: DateTimeFilter<"Designation"> | Date | string
    updatedAt?: DateTimeFilter<"Designation"> | Date | string
    employees?: EmployeeListRelationFilter
  }

  export type DesignationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type DesignationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    name?: StringFilter<"Designation"> | string
    description?: StringNullableFilter<"Designation"> | string | null
    isActive?: BoolFilter<"Designation"> | boolean
    createdAt?: DateTimeFilter<"Designation"> | Date | string
    updatedAt?: DateTimeFilter<"Designation"> | Date | string
    employees?: EmployeeListRelationFilter
  }, "id" | "code">

  export type DesignationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignationCountOrderByAggregateInput
    _max?: DesignationMaxOrderByAggregateInput
    _min?: DesignationMinOrderByAggregateInput
  }

  export type DesignationScalarWhereWithAggregatesInput = {
    AND?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    OR?: DesignationScalarWhereWithAggregatesInput[]
    NOT?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Designation"> | string
    name?: StringWithAggregatesFilter<"Designation"> | string
    code?: StringWithAggregatesFilter<"Designation"> | string
    description?: StringNullableWithAggregatesFilter<"Designation"> | string | null
    isActive?: BoolWithAggregatesFilter<"Designation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Designation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Designation"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    code?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    employees?: EmployeeListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    employees?: EmployeeListRelationFilter
  }, "id" | "code">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    code?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeCode?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    branchId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designationId?: StringNullableFilter<"Employee"> | string | null
    categoryId?: StringNullableFilter<"Employee"> | string | null
    shiftId?: StringNullableFilter<"Employee"> | string | null
    deviceUserId?: StringNullableFilter<"Employee"> | string | null
    sourceEmployeeId?: StringNullableFilter<"Employee"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Employee"> | Date | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    basicSalary?: FloatFilter<"Employee"> | number
    hra?: FloatFilter<"Employee"> | number
    conveyance?: FloatFilter<"Employee"> | number
    medicalAllowance?: FloatFilter<"Employee"> | number
    specialAllowance?: FloatFilter<"Employee"> | number
    otherAllowances?: FloatFilter<"Employee"> | number
    standardDeductions?: FloatFilter<"Employee"> | number
    bankName?: StringNullableFilter<"Employee"> | string | null
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    ifscCode?: StringNullableFilter<"Employee"> | string | null
    panNumber?: StringNullableFilter<"Employee"> | string | null
    aadhaarNumber?: StringNullableFilter<"Employee"> | string | null
    isPFEnabled?: BoolFilter<"Employee"> | boolean
    isESIEnabled?: BoolFilter<"Employee"> | boolean
    isPTEnabled?: BoolFilter<"Employee"> | boolean
    isOTEnabled?: BoolFilter<"Employee"> | boolean
    otRateMultiplier?: FloatFilter<"Employee"> | number
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    designation?: XOR<DesignationNullableRelationFilter, DesignationWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    managedDepartments?: DepartmentListRelationFilter
    managerApprovedLeaves?: LeaveEntryListRelationFilter
    ceoApprovedLeaves?: LeaveEntryListRelationFilter
    attendanceLogs?: AttendanceLogListRelationFilter
    leaveEntries?: LeaveEntryListRelationFilter
    employeeShifts?: EmployeeShiftListRelationFilter
    payrolls?: PayrollListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designationId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    deviceUserId?: SortOrderInput | SortOrder
    sourceEmployeeId?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadhaarNumber?: SortOrderInput | SortOrder
    isPFEnabled?: SortOrder
    isESIEnabled?: SortOrder
    isPTEnabled?: SortOrder
    isOTEnabled?: SortOrder
    otRateMultiplier?: SortOrder
    branch?: BranchOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    designation?: DesignationOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    managedDepartments?: DepartmentOrderByRelationAggregateInput
    managerApprovedLeaves?: LeaveEntryOrderByRelationAggregateInput
    ceoApprovedLeaves?: LeaveEntryOrderByRelationAggregateInput
    attendanceLogs?: AttendanceLogOrderByRelationAggregateInput
    leaveEntries?: LeaveEntryOrderByRelationAggregateInput
    employeeShifts?: EmployeeShiftOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeCode?: string
    sourceEmployeeId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    branchId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designationId?: StringNullableFilter<"Employee"> | string | null
    categoryId?: StringNullableFilter<"Employee"> | string | null
    shiftId?: StringNullableFilter<"Employee"> | string | null
    deviceUserId?: StringNullableFilter<"Employee"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Employee"> | Date | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    basicSalary?: FloatFilter<"Employee"> | number
    hra?: FloatFilter<"Employee"> | number
    conveyance?: FloatFilter<"Employee"> | number
    medicalAllowance?: FloatFilter<"Employee"> | number
    specialAllowance?: FloatFilter<"Employee"> | number
    otherAllowances?: FloatFilter<"Employee"> | number
    standardDeductions?: FloatFilter<"Employee"> | number
    bankName?: StringNullableFilter<"Employee"> | string | null
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    ifscCode?: StringNullableFilter<"Employee"> | string | null
    panNumber?: StringNullableFilter<"Employee"> | string | null
    aadhaarNumber?: StringNullableFilter<"Employee"> | string | null
    isPFEnabled?: BoolFilter<"Employee"> | boolean
    isESIEnabled?: BoolFilter<"Employee"> | boolean
    isPTEnabled?: BoolFilter<"Employee"> | boolean
    isOTEnabled?: BoolFilter<"Employee"> | boolean
    otRateMultiplier?: FloatFilter<"Employee"> | number
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    designation?: XOR<DesignationNullableRelationFilter, DesignationWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    managedDepartments?: DepartmentListRelationFilter
    managerApprovedLeaves?: LeaveEntryListRelationFilter
    ceoApprovedLeaves?: LeaveEntryListRelationFilter
    attendanceLogs?: AttendanceLogListRelationFilter
    leaveEntries?: LeaveEntryListRelationFilter
    employeeShifts?: EmployeeShiftListRelationFilter
    payrolls?: PayrollListRelationFilter
  }, "id" | "employeeCode" | "sourceEmployeeId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designationId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    deviceUserId?: SortOrderInput | SortOrder
    sourceEmployeeId?: SortOrderInput | SortOrder
    dateOfJoining?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadhaarNumber?: SortOrderInput | SortOrder
    isPFEnabled?: SortOrder
    isESIEnabled?: SortOrder
    isPTEnabled?: SortOrder
    isOTEnabled?: SortOrder
    otRateMultiplier?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employeeCode?: StringWithAggregatesFilter<"Employee"> | string
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    designationId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    shiftId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    deviceUserId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    sourceEmployeeId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    dateOfJoining?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    basicSalary?: FloatWithAggregatesFilter<"Employee"> | number
    hra?: FloatWithAggregatesFilter<"Employee"> | number
    conveyance?: FloatWithAggregatesFilter<"Employee"> | number
    medicalAllowance?: FloatWithAggregatesFilter<"Employee"> | number
    specialAllowance?: FloatWithAggregatesFilter<"Employee"> | number
    otherAllowances?: FloatWithAggregatesFilter<"Employee"> | number
    standardDeductions?: FloatWithAggregatesFilter<"Employee"> | number
    bankName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    ifscCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    aadhaarNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    isPFEnabled?: BoolWithAggregatesFilter<"Employee"> | boolean
    isESIEnabled?: BoolWithAggregatesFilter<"Employee"> | boolean
    isPTEnabled?: BoolWithAggregatesFilter<"Employee"> | boolean
    isOTEnabled?: BoolWithAggregatesFilter<"Employee"> | boolean
    otRateMultiplier?: FloatWithAggregatesFilter<"Employee"> | number
  }

  export type CompanyProfileWhereInput = {
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    id?: StringFilter<"CompanyProfile"> | string
    name?: StringFilter<"CompanyProfile"> | string
    legalName?: StringNullableFilter<"CompanyProfile"> | string | null
    address?: StringNullableFilter<"CompanyProfile"> | string | null
    logo?: StringNullableFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableFilter<"CompanyProfile"> | string | null
    pan?: StringNullableFilter<"CompanyProfile"> | string | null
    pfCode?: StringNullableFilter<"CompanyProfile"> | string | null
    esiCode?: StringNullableFilter<"CompanyProfile"> | string | null
    tan?: StringNullableFilter<"CompanyProfile"> | string | null
    bankName?: StringNullableFilter<"CompanyProfile"> | string | null
    accountNumber?: StringNullableFilter<"CompanyProfile"> | string | null
    ifscCode?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
  }

  export type CompanyProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    pfCode?: SortOrderInput | SortOrder
    esiCode?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    name?: StringFilter<"CompanyProfile"> | string
    legalName?: StringNullableFilter<"CompanyProfile"> | string | null
    address?: StringNullableFilter<"CompanyProfile"> | string | null
    logo?: StringNullableFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableFilter<"CompanyProfile"> | string | null
    pan?: StringNullableFilter<"CompanyProfile"> | string | null
    pfCode?: StringNullableFilter<"CompanyProfile"> | string | null
    esiCode?: StringNullableFilter<"CompanyProfile"> | string | null
    tan?: StringNullableFilter<"CompanyProfile"> | string | null
    bankName?: StringNullableFilter<"CompanyProfile"> | string | null
    accountNumber?: StringNullableFilter<"CompanyProfile"> | string | null
    ifscCode?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
  }, "id">

  export type CompanyProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    pfCode?: SortOrderInput | SortOrder
    esiCode?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyProfileCountOrderByAggregateInput
    _max?: CompanyProfileMaxOrderByAggregateInput
    _min?: CompanyProfileMinOrderByAggregateInput
  }

  export type CompanyProfileScalarWhereWithAggregatesInput = {
    AND?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    OR?: CompanyProfileScalarWhereWithAggregatesInput[]
    NOT?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyProfile"> | string
    name?: StringWithAggregatesFilter<"CompanyProfile"> | string
    legalName?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    logo?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    pan?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    pfCode?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    esiCode?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    tan?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    ifscCode?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    gracePeriodIn?: IntFilter<"Shift"> | number
    gracePeriodOut?: IntFilter<"Shift"> | number
    isNightShift?: BoolFilter<"Shift"> | boolean
    isActive?: BoolFilter<"Shift"> | boolean
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    employees?: EmployeeListRelationFilter
    employeeShifts?: EmployeeShiftListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    employeeShifts?: EmployeeShiftOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    name?: StringFilter<"Shift"> | string
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    gracePeriodIn?: IntFilter<"Shift"> | number
    gracePeriodOut?: IntFilter<"Shift"> | number
    isNightShift?: BoolFilter<"Shift"> | boolean
    isActive?: BoolFilter<"Shift"> | boolean
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    employees?: EmployeeListRelationFilter
    employeeShifts?: EmployeeShiftListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    name?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: StringWithAggregatesFilter<"Shift"> | string
    endTime?: StringWithAggregatesFilter<"Shift"> | string
    gracePeriodIn?: IntWithAggregatesFilter<"Shift"> | number
    gracePeriodOut?: IntWithAggregatesFilter<"Shift"> | number
    isNightShift?: BoolWithAggregatesFilter<"Shift"> | boolean
    isActive?: BoolWithAggregatesFilter<"Shift"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type EmployeeShiftWhereInput = {
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    id?: StringFilter<"EmployeeShift"> | string
    employeeId?: StringFilter<"EmployeeShift"> | string
    shiftId?: StringFilter<"EmployeeShift"> | string
    startDate?: DateTimeFilter<"EmployeeShift"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeShift"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeShift"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftRelationFilter, ShiftWhereInput>
  }

  export type EmployeeShiftOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
  }

  export type EmployeeShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    employeeId?: StringFilter<"EmployeeShift"> | string
    shiftId?: StringFilter<"EmployeeShift"> | string
    startDate?: DateTimeFilter<"EmployeeShift"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeShift"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeShift"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftRelationFilter, ShiftWhereInput>
  }, "id">

  export type EmployeeShiftOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeShiftCountOrderByAggregateInput
    _max?: EmployeeShiftMaxOrderByAggregateInput
    _min?: EmployeeShiftMinOrderByAggregateInput
  }

  export type EmployeeShiftScalarWhereWithAggregatesInput = {
    AND?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    OR?: EmployeeShiftScalarWhereWithAggregatesInput[]
    NOT?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeShift"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeShift"> | string
    shiftId?: StringWithAggregatesFilter<"EmployeeShift"> | string
    startDate?: DateTimeWithAggregatesFilter<"EmployeeShift"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"EmployeeShift"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeShift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeShift"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    date?: DateTimeFilter<"Holiday"> | Date | string
    description?: StringNullableFilter<"Holiday"> | string | null
    isRecurring?: BoolFilter<"Holiday"> | boolean
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    date?: DateTimeFilter<"Holiday"> | Date | string
    description?: StringNullableFilter<"Holiday"> | string | null
    isRecurring?: BoolFilter<"Holiday"> | boolean
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }, "id">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Holiday"> | string
    name?: StringWithAggregatesFilter<"Holiday"> | string
    date?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"Holiday"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
  }

  export type LeaveTypeWhereInput = {
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    description?: StringNullableFilter<"LeaveType"> | string | null
    isPaid?: BoolFilter<"LeaveType"> | boolean
    isActive?: BoolFilter<"LeaveType"> | boolean
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    leaveEntries?: LeaveEntryListRelationFilter
  }

  export type LeaveTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leaveEntries?: LeaveEntryOrderByRelationAggregateInput
  }

  export type LeaveTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    name?: StringFilter<"LeaveType"> | string
    description?: StringNullableFilter<"LeaveType"> | string | null
    isPaid?: BoolFilter<"LeaveType"> | boolean
    isActive?: BoolFilter<"LeaveType"> | boolean
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    leaveEntries?: LeaveEntryListRelationFilter
  }, "id" | "code">

  export type LeaveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveTypeCountOrderByAggregateInput
    _max?: LeaveTypeMaxOrderByAggregateInput
    _min?: LeaveTypeMinOrderByAggregateInput
  }

  export type LeaveTypeScalarWhereWithAggregatesInput = {
    AND?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    OR?: LeaveTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveType"> | string
    name?: StringWithAggregatesFilter<"LeaveType"> | string
    code?: StringWithAggregatesFilter<"LeaveType"> | string
    description?: StringNullableWithAggregatesFilter<"LeaveType"> | string | null
    isPaid?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    isActive?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
  }

  export type LeaveEntryWhereInput = {
    AND?: LeaveEntryWhereInput | LeaveEntryWhereInput[]
    OR?: LeaveEntryWhereInput[]
    NOT?: LeaveEntryWhereInput | LeaveEntryWhereInput[]
    id?: StringFilter<"LeaveEntry"> | string
    employeeId?: StringFilter<"LeaveEntry"> | string
    leaveTypeId?: StringFilter<"LeaveEntry"> | string
    startDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    days?: FloatFilter<"LeaveEntry"> | number
    reason?: StringNullableFilter<"LeaveEntry"> | string | null
    status?: StringFilter<"LeaveEntry"> | string
    managerApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    managerApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    managerId?: StringNullableFilter<"LeaveEntry"> | string | null
    ceoApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    ceoApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    ceoId?: StringNullableFilter<"LeaveEntry"> | string | null
    createdAt?: DateTimeFilter<"LeaveEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveEntry"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeRelationFilter, LeaveTypeWhereInput>
    manager?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    ceo?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }

  export type LeaveEntryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    managerApproval?: SortOrderInput | SortOrder
    managerApprovedAt?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    ceoApproval?: SortOrderInput | SortOrder
    ceoApprovedAt?: SortOrderInput | SortOrder
    ceoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
    manager?: EmployeeOrderByWithRelationInput
    ceo?: EmployeeOrderByWithRelationInput
  }

  export type LeaveEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveEntryWhereInput | LeaveEntryWhereInput[]
    OR?: LeaveEntryWhereInput[]
    NOT?: LeaveEntryWhereInput | LeaveEntryWhereInput[]
    employeeId?: StringFilter<"LeaveEntry"> | string
    leaveTypeId?: StringFilter<"LeaveEntry"> | string
    startDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    days?: FloatFilter<"LeaveEntry"> | number
    reason?: StringNullableFilter<"LeaveEntry"> | string | null
    status?: StringFilter<"LeaveEntry"> | string
    managerApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    managerApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    managerId?: StringNullableFilter<"LeaveEntry"> | string | null
    ceoApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    ceoApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    ceoId?: StringNullableFilter<"LeaveEntry"> | string | null
    createdAt?: DateTimeFilter<"LeaveEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveEntry"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeRelationFilter, LeaveTypeWhereInput>
    manager?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    ceo?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type LeaveEntryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    managerApproval?: SortOrderInput | SortOrder
    managerApprovedAt?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    ceoApproval?: SortOrderInput | SortOrder
    ceoApprovedAt?: SortOrderInput | SortOrder
    ceoId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveEntryCountOrderByAggregateInput
    _avg?: LeaveEntryAvgOrderByAggregateInput
    _max?: LeaveEntryMaxOrderByAggregateInput
    _min?: LeaveEntryMinOrderByAggregateInput
    _sum?: LeaveEntrySumOrderByAggregateInput
  }

  export type LeaveEntryScalarWhereWithAggregatesInput = {
    AND?: LeaveEntryScalarWhereWithAggregatesInput | LeaveEntryScalarWhereWithAggregatesInput[]
    OR?: LeaveEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaveEntryScalarWhereWithAggregatesInput | LeaveEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveEntry"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveEntry"> | string
    leaveTypeId?: StringWithAggregatesFilter<"LeaveEntry"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveEntry"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveEntry"> | Date | string
    days?: FloatWithAggregatesFilter<"LeaveEntry"> | number
    reason?: StringNullableWithAggregatesFilter<"LeaveEntry"> | string | null
    status?: StringWithAggregatesFilter<"LeaveEntry"> | string
    managerApproval?: BoolNullableWithAggregatesFilter<"LeaveEntry"> | boolean | null
    managerApprovedAt?: DateTimeNullableWithAggregatesFilter<"LeaveEntry"> | Date | string | null
    managerId?: StringNullableWithAggregatesFilter<"LeaveEntry"> | string | null
    ceoApproval?: BoolNullableWithAggregatesFilter<"LeaveEntry"> | boolean | null
    ceoApprovedAt?: DateTimeNullableWithAggregatesFilter<"LeaveEntry"> | Date | string | null
    ceoId?: StringNullableWithAggregatesFilter<"LeaveEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveEntry"> | Date | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    deviceId?: StringFilter<"Device"> | string
    name?: StringFilter<"Device"> | string
    ipAddress?: StringNullableFilter<"Device"> | string | null
    port?: IntNullableFilter<"Device"> | number | null
    location?: StringNullableFilter<"Device"> | string | null
    status?: StringFilter<"Device"> | string
    lastConnected?: DateTimeNullableFilter<"Device"> | Date | string | null
    isActive?: BoolFilter<"Device"> | boolean
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    deviceUsers?: DeviceUserListRelationFilter
    rawDeviceLogs?: RawDeviceLogListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    lastConnected?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceUsers?: DeviceUserOrderByRelationAggregateInput
    rawDeviceLogs?: RawDeviceLogOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    name?: StringFilter<"Device"> | string
    ipAddress?: StringNullableFilter<"Device"> | string | null
    port?: IntNullableFilter<"Device"> | number | null
    location?: StringNullableFilter<"Device"> | string | null
    status?: StringFilter<"Device"> | string
    lastConnected?: DateTimeNullableFilter<"Device"> | Date | string | null
    isActive?: BoolFilter<"Device"> | boolean
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    deviceUsers?: DeviceUserListRelationFilter
    rawDeviceLogs?: RawDeviceLogListRelationFilter
  }, "id" | "deviceId">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    lastConnected?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    deviceId?: StringWithAggregatesFilter<"Device"> | string
    name?: StringWithAggregatesFilter<"Device"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Device"> | string | null
    port?: IntNullableWithAggregatesFilter<"Device"> | number | null
    location?: StringNullableWithAggregatesFilter<"Device"> | string | null
    status?: StringWithAggregatesFilter<"Device"> | string
    lastConnected?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Device"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type DeviceUserWhereInput = {
    AND?: DeviceUserWhereInput | DeviceUserWhereInput[]
    OR?: DeviceUserWhereInput[]
    NOT?: DeviceUserWhereInput | DeviceUserWhereInput[]
    id?: StringFilter<"DeviceUser"> | string
    deviceId?: StringFilter<"DeviceUser"> | string
    deviceUserId?: StringFilter<"DeviceUser"> | string
    employeeId?: StringNullableFilter<"DeviceUser"> | string | null
    name?: StringNullableFilter<"DeviceUser"> | string | null
    createdAt?: DateTimeFilter<"DeviceUser"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceUser"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type DeviceUserOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    deviceUserId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type DeviceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId_deviceUserId?: DeviceUserDeviceIdDeviceUserIdCompoundUniqueInput
    AND?: DeviceUserWhereInput | DeviceUserWhereInput[]
    OR?: DeviceUserWhereInput[]
    NOT?: DeviceUserWhereInput | DeviceUserWhereInput[]
    deviceId?: StringFilter<"DeviceUser"> | string
    deviceUserId?: StringFilter<"DeviceUser"> | string
    employeeId?: StringNullableFilter<"DeviceUser"> | string | null
    name?: StringNullableFilter<"DeviceUser"> | string | null
    createdAt?: DateTimeFilter<"DeviceUser"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceUser"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id" | "deviceId_deviceUserId">

  export type DeviceUserOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    deviceUserId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceUserCountOrderByAggregateInput
    _max?: DeviceUserMaxOrderByAggregateInput
    _min?: DeviceUserMinOrderByAggregateInput
  }

  export type DeviceUserScalarWhereWithAggregatesInput = {
    AND?: DeviceUserScalarWhereWithAggregatesInput | DeviceUserScalarWhereWithAggregatesInput[]
    OR?: DeviceUserScalarWhereWithAggregatesInput[]
    NOT?: DeviceUserScalarWhereWithAggregatesInput | DeviceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceUser"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceUser"> | string
    deviceUserId?: StringWithAggregatesFilter<"DeviceUser"> | string
    employeeId?: StringNullableWithAggregatesFilter<"DeviceUser"> | string | null
    name?: StringNullableWithAggregatesFilter<"DeviceUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeviceUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceUser"> | Date | string
  }

  export type RawDeviceLogWhereInput = {
    AND?: RawDeviceLogWhereInput | RawDeviceLogWhereInput[]
    OR?: RawDeviceLogWhereInput[]
    NOT?: RawDeviceLogWhereInput | RawDeviceLogWhereInput[]
    id?: StringFilter<"RawDeviceLog"> | string
    deviceId?: StringFilter<"RawDeviceLog"> | string
    userId?: StringFilter<"RawDeviceLog"> | string
    punchTime?: DateTimeFilter<"RawDeviceLog"> | Date | string
    punchType?: StringNullableFilter<"RawDeviceLog"> | string | null
    isProcessed?: BoolFilter<"RawDeviceLog"> | boolean
    createdAt?: DateTimeFilter<"RawDeviceLog"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type RawDeviceLogOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    punchTime?: SortOrder
    punchType?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type RawDeviceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RawDeviceLogWhereInput | RawDeviceLogWhereInput[]
    OR?: RawDeviceLogWhereInput[]
    NOT?: RawDeviceLogWhereInput | RawDeviceLogWhereInput[]
    deviceId?: StringFilter<"RawDeviceLog"> | string
    userId?: StringFilter<"RawDeviceLog"> | string
    punchTime?: DateTimeFilter<"RawDeviceLog"> | Date | string
    punchType?: StringNullableFilter<"RawDeviceLog"> | string | null
    isProcessed?: BoolFilter<"RawDeviceLog"> | boolean
    createdAt?: DateTimeFilter<"RawDeviceLog"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id">

  export type RawDeviceLogOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    punchTime?: SortOrder
    punchType?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    _count?: RawDeviceLogCountOrderByAggregateInput
    _max?: RawDeviceLogMaxOrderByAggregateInput
    _min?: RawDeviceLogMinOrderByAggregateInput
  }

  export type RawDeviceLogScalarWhereWithAggregatesInput = {
    AND?: RawDeviceLogScalarWhereWithAggregatesInput | RawDeviceLogScalarWhereWithAggregatesInput[]
    OR?: RawDeviceLogScalarWhereWithAggregatesInput[]
    NOT?: RawDeviceLogScalarWhereWithAggregatesInput | RawDeviceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RawDeviceLog"> | string
    deviceId?: StringWithAggregatesFilter<"RawDeviceLog"> | string
    userId?: StringWithAggregatesFilter<"RawDeviceLog"> | string
    punchTime?: DateTimeWithAggregatesFilter<"RawDeviceLog"> | Date | string
    punchType?: StringNullableWithAggregatesFilter<"RawDeviceLog"> | string | null
    isProcessed?: BoolWithAggregatesFilter<"RawDeviceLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RawDeviceLog"> | Date | string
  }

  export type AttendanceLogWhereInput = {
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    id?: StringFilter<"AttendanceLog"> | string
    employeeId?: StringFilter<"AttendanceLog"> | string
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    firstIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lastOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    workingHours?: FloatNullableFilter<"AttendanceLog"> | number | null
    shiftStart?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    shiftEnd?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lateArrival?: IntFilter<"AttendanceLog"> | number
    earlyDeparture?: IntFilter<"AttendanceLog"> | number
    status?: StringFilter<"AttendanceLog"> | string
    totalPunches?: IntFilter<"AttendanceLog"> | number
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type AttendanceLogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    firstIn?: SortOrderInput | SortOrder
    lastOut?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    shiftStart?: SortOrderInput | SortOrder
    shiftEnd?: SortOrderInput | SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    status?: SortOrder
    totalPunches?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AttendanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_date?: AttendanceLogEmployeeIdDateCompoundUniqueInput
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    employeeId?: StringFilter<"AttendanceLog"> | string
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    firstIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lastOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    workingHours?: FloatNullableFilter<"AttendanceLog"> | number | null
    shiftStart?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    shiftEnd?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lateArrival?: IntFilter<"AttendanceLog"> | number
    earlyDeparture?: IntFilter<"AttendanceLog"> | number
    status?: StringFilter<"AttendanceLog"> | string
    totalPunches?: IntFilter<"AttendanceLog"> | number
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_date">

  export type AttendanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    firstIn?: SortOrderInput | SortOrder
    lastOut?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    shiftStart?: SortOrderInput | SortOrder
    shiftEnd?: SortOrderInput | SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    status?: SortOrder
    totalPunches?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceLogCountOrderByAggregateInput
    _avg?: AttendanceLogAvgOrderByAggregateInput
    _max?: AttendanceLogMaxOrderByAggregateInput
    _min?: AttendanceLogMinOrderByAggregateInput
    _sum?: AttendanceLogSumOrderByAggregateInput
  }

  export type AttendanceLogScalarWhereWithAggregatesInput = {
    AND?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    OR?: AttendanceLogScalarWhereWithAggregatesInput[]
    NOT?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceLog"> | string
    employeeId?: StringWithAggregatesFilter<"AttendanceLog"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
    firstIn?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    lastOut?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    workingHours?: FloatNullableWithAggregatesFilter<"AttendanceLog"> | number | null
    shiftStart?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    shiftEnd?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    lateArrival?: IntWithAggregatesFilter<"AttendanceLog"> | number
    earlyDeparture?: IntWithAggregatesFilter<"AttendanceLog"> | number
    status?: StringWithAggregatesFilter<"AttendanceLog"> | string
    totalPunches?: IntWithAggregatesFilter<"AttendanceLog"> | number
    rawData?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
  }

  export type SyncStatusWhereInput = {
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    id?: StringFilter<"SyncStatus"> | string
    lastSyncTime?: DateTimeFilter<"SyncStatus"> | Date | string
    recordsSynced?: IntFilter<"SyncStatus"> | number
    status?: StringFilter<"SyncStatus"> | string
    message?: StringNullableFilter<"SyncStatus"> | string | null
    createdAt?: DateTimeFilter<"SyncStatus"> | Date | string
  }

  export type SyncStatusOrderByWithRelationInput = {
    id?: SortOrder
    lastSyncTime?: SortOrder
    recordsSynced?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SyncStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    lastSyncTime?: DateTimeFilter<"SyncStatus"> | Date | string
    recordsSynced?: IntFilter<"SyncStatus"> | number
    status?: StringFilter<"SyncStatus"> | string
    message?: StringNullableFilter<"SyncStatus"> | string | null
    createdAt?: DateTimeFilter<"SyncStatus"> | Date | string
  }, "id">

  export type SyncStatusOrderByWithAggregationInput = {
    id?: SortOrder
    lastSyncTime?: SortOrder
    recordsSynced?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SyncStatusCountOrderByAggregateInput
    _avg?: SyncStatusAvgOrderByAggregateInput
    _max?: SyncStatusMaxOrderByAggregateInput
    _min?: SyncStatusMinOrderByAggregateInput
    _sum?: SyncStatusSumOrderByAggregateInput
  }

  export type SyncStatusScalarWhereWithAggregatesInput = {
    AND?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    OR?: SyncStatusScalarWhereWithAggregatesInput[]
    NOT?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncStatus"> | string
    lastSyncTime?: DateTimeWithAggregatesFilter<"SyncStatus"> | Date | string
    recordsSynced?: IntWithAggregatesFilter<"SyncStatus"> | number
    status?: StringWithAggregatesFilter<"SyncStatus"> | string
    message?: StringNullableWithAggregatesFilter<"SyncStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncStatus"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    totalWorkingDays?: IntFilter<"Payroll"> | number
    actualPresentDays?: FloatFilter<"Payroll"> | number
    lopDays?: FloatFilter<"Payroll"> | number
    paidDays?: FloatFilter<"Payroll"> | number
    basicPaid?: FloatFilter<"Payroll"> | number
    hraPaid?: FloatFilter<"Payroll"> | number
    conveyancePaid?: FloatFilter<"Payroll"> | number
    medicalPaid?: FloatFilter<"Payroll"> | number
    specialPaid?: FloatFilter<"Payroll"> | number
    allowancesPaid?: FloatFilter<"Payroll"> | number
    bonus?: FloatFilter<"Payroll"> | number
    incentives?: FloatFilter<"Payroll"> | number
    arrears?: FloatFilter<"Payroll"> | number
    otHours?: FloatFilter<"Payroll"> | number
    otPay?: FloatFilter<"Payroll"> | number
    pfDeduction?: FloatFilter<"Payroll"> | number
    esiDeduction?: FloatFilter<"Payroll"> | number
    ptDeduction?: FloatFilter<"Payroll"> | number
    tdsDeduction?: FloatFilter<"Payroll"> | number
    otherDeductions?: FloatFilter<"Payroll"> | number
    employerPF?: FloatFilter<"Payroll"> | number
    employerESI?: FloatFilter<"Payroll"> | number
    grossSalary?: FloatFilter<"Payroll"> | number
    totalDeductions?: FloatFilter<"Payroll"> | number
    netSalary?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    remarks?: StringNullableFilter<"Payroll"> | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_month_year?: PayrollEmployeeIdMonthYearCompoundUniqueInput
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    totalWorkingDays?: IntFilter<"Payroll"> | number
    actualPresentDays?: FloatFilter<"Payroll"> | number
    lopDays?: FloatFilter<"Payroll"> | number
    paidDays?: FloatFilter<"Payroll"> | number
    basicPaid?: FloatFilter<"Payroll"> | number
    hraPaid?: FloatFilter<"Payroll"> | number
    conveyancePaid?: FloatFilter<"Payroll"> | number
    medicalPaid?: FloatFilter<"Payroll"> | number
    specialPaid?: FloatFilter<"Payroll"> | number
    allowancesPaid?: FloatFilter<"Payroll"> | number
    bonus?: FloatFilter<"Payroll"> | number
    incentives?: FloatFilter<"Payroll"> | number
    arrears?: FloatFilter<"Payroll"> | number
    otHours?: FloatFilter<"Payroll"> | number
    otPay?: FloatFilter<"Payroll"> | number
    pfDeduction?: FloatFilter<"Payroll"> | number
    esiDeduction?: FloatFilter<"Payroll"> | number
    ptDeduction?: FloatFilter<"Payroll"> | number
    tdsDeduction?: FloatFilter<"Payroll"> | number
    otherDeductions?: FloatFilter<"Payroll"> | number
    employerPF?: FloatFilter<"Payroll"> | number
    employerESI?: FloatFilter<"Payroll"> | number
    grossSalary?: FloatFilter<"Payroll"> | number
    totalDeductions?: FloatFilter<"Payroll"> | number
    netSalary?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    remarks?: StringNullableFilter<"Payroll"> | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_month_year">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    employeeId?: StringWithAggregatesFilter<"Payroll"> | string
    month?: IntWithAggregatesFilter<"Payroll"> | number
    year?: IntWithAggregatesFilter<"Payroll"> | number
    totalWorkingDays?: IntWithAggregatesFilter<"Payroll"> | number
    actualPresentDays?: FloatWithAggregatesFilter<"Payroll"> | number
    lopDays?: FloatWithAggregatesFilter<"Payroll"> | number
    paidDays?: FloatWithAggregatesFilter<"Payroll"> | number
    basicPaid?: FloatWithAggregatesFilter<"Payroll"> | number
    hraPaid?: FloatWithAggregatesFilter<"Payroll"> | number
    conveyancePaid?: FloatWithAggregatesFilter<"Payroll"> | number
    medicalPaid?: FloatWithAggregatesFilter<"Payroll"> | number
    specialPaid?: FloatWithAggregatesFilter<"Payroll"> | number
    allowancesPaid?: FloatWithAggregatesFilter<"Payroll"> | number
    bonus?: FloatWithAggregatesFilter<"Payroll"> | number
    incentives?: FloatWithAggregatesFilter<"Payroll"> | number
    arrears?: FloatWithAggregatesFilter<"Payroll"> | number
    otHours?: FloatWithAggregatesFilter<"Payroll"> | number
    otPay?: FloatWithAggregatesFilter<"Payroll"> | number
    pfDeduction?: FloatWithAggregatesFilter<"Payroll"> | number
    esiDeduction?: FloatWithAggregatesFilter<"Payroll"> | number
    ptDeduction?: FloatWithAggregatesFilter<"Payroll"> | number
    tdsDeduction?: FloatWithAggregatesFilter<"Payroll"> | number
    otherDeductions?: FloatWithAggregatesFilter<"Payroll"> | number
    employerPF?: FloatWithAggregatesFilter<"Payroll"> | number
    employerESI?: FloatWithAggregatesFilter<"Payroll"> | number
    grossSalary?: FloatWithAggregatesFilter<"Payroll"> | number
    totalDeductions?: FloatWithAggregatesFilter<"Payroll"> | number
    netSalary?: FloatWithAggregatesFilter<"Payroll"> | number
    status?: StringWithAggregatesFilter<"Payroll"> | string
    remarks?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    role?: string
    employeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    role?: string
    employeeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zipCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: BranchCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zipCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: BranchUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: BranchUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: BranchUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zipCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutBranchesInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    departments?: DepartmentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutBranchesNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    name: string
    code: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutDepartmentsInput
    manager?: EmployeeCreateNestedOneWithoutManagedDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    branchId?: string | null
    managerId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutDepartmentsNestedInput
    manager?: EmployeeUpdateOneWithoutManagedDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    code: string
    branchId?: string | null
    managerId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type CompanyProfileCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    address?: string | null
    logo?: string | null
    gstin?: string | null
    pan?: string | null
    pfCode?: string | null
    esiCode?: string | null
    tan?: string | null
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUncheckedCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    address?: string | null
    logo?: string | null
    gstin?: string | null
    pan?: string | null
    pfCode?: string | null
    esiCode?: string | null
    tan?: string | null
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    pfCode?: NullableStringFieldUpdateOperationsInput | string | null
    esiCode?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    pfCode?: NullableStringFieldUpdateOperationsInput | string | null
    esiCode?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileCreateManyInput = {
    id?: string
    name: string
    legalName?: string | null
    address?: string | null
    logo?: string | null
    gstin?: string | null
    pan?: string | null
    pfCode?: string | null
    esiCode?: string | null
    tan?: string | null
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    pfCode?: NullableStringFieldUpdateOperationsInput | string | null
    esiCode?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    pfCode?: NullableStringFieldUpdateOperationsInput | string | null
    esiCode?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutShiftInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeeShiftsInput
    shift: ShiftCreateNestedOneWithoutEmployeeShiftsInput
  }

  export type EmployeeShiftUncheckedCreateInput = {
    id?: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeeShiftsNestedInput
    shift?: ShiftUpdateOneRequiredWithoutEmployeeShiftsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftCreateManyInput = {
    id?: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    id?: string
    name: string
    date: Date | string
    description?: string | null
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUncheckedCreateInput = {
    id?: string
    name: string
    date: Date | string
    description?: string | null
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyInput = {
    id?: string
    name: string
    date: Date | string
    description?: string | null
    isRecurring?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isPaid?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveEntries?: LeaveEntryCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isPaid?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveEntries?: LeaveEntryUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isPaid?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveEntriesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveEntriesInput
    manager?: EmployeeCreateNestedOneWithoutManagerApprovedLeavesInput
    ceo?: EmployeeCreateNestedOneWithoutCeoApprovedLeavesInput
  }

  export type LeaveEntryUncheckedCreateInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    manager?: EmployeeUpdateOneWithoutManagerApprovedLeavesNestedInput
    ceo?: EmployeeUpdateOneWithoutCeoApprovedLeavesNestedInput
  }

  export type LeaveEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryCreateManyInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceUsers?: DeviceUserCreateNestedManyWithoutDeviceInput
    rawDeviceLogs?: RawDeviceLogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceUsers?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    rawDeviceLogs?: RawDeviceLogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceUsers?: DeviceUserUpdateManyWithoutDeviceNestedInput
    rawDeviceLogs?: RawDeviceLogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceUsers?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    rawDeviceLogs?: RawDeviceLogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateInput = {
    id?: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    device: DeviceCreateNestedOneWithoutDeviceUsersInput
  }

  export type DeviceUserUncheckedCreateInput = {
    id?: string
    deviceId: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutDeviceUsersNestedInput
  }

  export type DeviceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyInput = {
    id?: string
    deviceId: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogCreateInput = {
    id?: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
    device: DeviceCreateNestedOneWithoutRawDeviceLogsInput
  }

  export type RawDeviceLogUncheckedCreateInput = {
    id?: string
    deviceId: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
  }

  export type RawDeviceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutRawDeviceLogsNestedInput
  }

  export type RawDeviceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogCreateManyInput = {
    id?: string
    deviceId: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
  }

  export type RawDeviceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateInput = {
    id?: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceLogsInput
  }

  export type AttendanceLogUncheckedCreateInput = {
    id?: string
    employeeId: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceLogsNestedInput
  }

  export type AttendanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyInput = {
    id?: string
    employeeId: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusCreateInput = {
    id?: string
    lastSyncTime: Date | string
    recordsSynced?: number
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SyncStatusUncheckedCreateInput = {
    id?: string
    lastSyncTime: Date | string
    recordsSynced?: number
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SyncStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    recordsSynced?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    recordsSynced?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusCreateManyInput = {
    id?: string
    lastSyncTime: Date | string
    recordsSynced?: number
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SyncStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    recordsSynced?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    recordsSynced?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    employeeId: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyInput = {
    id?: string
    employeeId: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeNullableRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type DepartmentCodeBranchIdCompoundUniqueInput = {
    code: string
    branchId: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    managerId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    managerId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    managerId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type DesignationNullableRelationFilter = {
    is?: DesignationWhereInput | null
    isNot?: DesignationWhereInput | null
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ShiftNullableRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LeaveEntryListRelationFilter = {
    every?: LeaveEntryWhereInput
    some?: LeaveEntryWhereInput
    none?: LeaveEntryWhereInput
  }

  export type AttendanceLogListRelationFilter = {
    every?: AttendanceLogWhereInput
    some?: AttendanceLogWhereInput
    none?: AttendanceLogWhereInput
  }

  export type EmployeeShiftListRelationFilter = {
    every?: EmployeeShiftWhereInput
    some?: EmployeeShiftWhereInput
    none?: EmployeeShiftWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type LeaveEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    categoryId?: SortOrder
    shiftId?: SortOrder
    deviceUserId?: SortOrder
    sourceEmployeeId?: SortOrder
    dateOfJoining?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    isPFEnabled?: SortOrder
    isESIEnabled?: SortOrder
    isPTEnabled?: SortOrder
    isOTEnabled?: SortOrder
    otRateMultiplier?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    otRateMultiplier?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    categoryId?: SortOrder
    shiftId?: SortOrder
    deviceUserId?: SortOrder
    sourceEmployeeId?: SortOrder
    dateOfJoining?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    isPFEnabled?: SortOrder
    isESIEnabled?: SortOrder
    isPTEnabled?: SortOrder
    isOTEnabled?: SortOrder
    otRateMultiplier?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    categoryId?: SortOrder
    shiftId?: SortOrder
    deviceUserId?: SortOrder
    sourceEmployeeId?: SortOrder
    dateOfJoining?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    isPFEnabled?: SortOrder
    isESIEnabled?: SortOrder
    isPTEnabled?: SortOrder
    isOTEnabled?: SortOrder
    otRateMultiplier?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    basicSalary?: SortOrder
    hra?: SortOrder
    conveyance?: SortOrder
    medicalAllowance?: SortOrder
    specialAllowance?: SortOrder
    otherAllowances?: SortOrder
    standardDeductions?: SortOrder
    otRateMultiplier?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CompanyProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    pfCode?: SortOrder
    esiCode?: SortOrder
    tan?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    pfCode?: SortOrder
    esiCode?: SortOrder
    tan?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    pfCode?: SortOrder
    esiCode?: SortOrder
    tan?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    gracePeriodIn?: SortOrder
    gracePeriodOut?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ShiftRelationFilter = {
    is?: ShiftWhereInput
    isNot?: ShiftWhereInput
  }

  export type EmployeeShiftCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeShiftMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    description?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    description?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    description?: SortOrder
    isRecurring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isPaid?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type LeaveTypeRelationFilter = {
    is?: LeaveTypeWhereInput
    isNot?: LeaveTypeWhereInput
  }

  export type LeaveEntryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    managerApproval?: SortOrder
    managerApprovedAt?: SortOrder
    managerId?: SortOrder
    ceoApproval?: SortOrder
    ceoApprovedAt?: SortOrder
    ceoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveEntryAvgOrderByAggregateInput = {
    days?: SortOrder
  }

  export type LeaveEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    managerApproval?: SortOrder
    managerApprovedAt?: SortOrder
    managerId?: SortOrder
    ceoApproval?: SortOrder
    ceoApprovedAt?: SortOrder
    ceoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveEntryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    managerApproval?: SortOrder
    managerApprovedAt?: SortOrder
    managerId?: SortOrder
    ceoApproval?: SortOrder
    ceoApprovedAt?: SortOrder
    ceoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveEntrySumOrderByAggregateInput = {
    days?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DeviceUserListRelationFilter = {
    every?: DeviceUserWhereInput
    some?: DeviceUserWhereInput
    none?: DeviceUserWhereInput
  }

  export type RawDeviceLogListRelationFilter = {
    every?: RawDeviceLogWhereInput
    some?: RawDeviceLogWhereInput
    none?: RawDeviceLogWhereInput
  }

  export type DeviceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RawDeviceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastConnected?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastConnected?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    location?: SortOrder
    status?: SortOrder
    lastConnected?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DeviceRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type DeviceUserDeviceIdDeviceUserIdCompoundUniqueInput = {
    deviceId: string
    deviceUserId: string
  }

  export type DeviceUserCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    deviceUserId?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    deviceUserId?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceUserMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    deviceUserId?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RawDeviceLogCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    punchTime?: SortOrder
    punchType?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type RawDeviceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    punchTime?: SortOrder
    punchType?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type RawDeviceLogMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    punchTime?: SortOrder
    punchType?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AttendanceLogEmployeeIdDateCompoundUniqueInput = {
    employeeId: string
    date: Date | string
  }

  export type AttendanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workingHours?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    status?: SortOrder
    totalPunches?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogAvgOrderByAggregateInput = {
    workingHours?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    totalPunches?: SortOrder
  }

  export type AttendanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workingHours?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    status?: SortOrder
    totalPunches?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    firstIn?: SortOrder
    lastOut?: SortOrder
    workingHours?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    status?: SortOrder
    totalPunches?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceLogSumOrderByAggregateInput = {
    workingHours?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    totalPunches?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SyncStatusCountOrderByAggregateInput = {
    id?: SortOrder
    lastSyncTime?: SortOrder
    recordsSynced?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncStatusAvgOrderByAggregateInput = {
    recordsSynced?: SortOrder
  }

  export type SyncStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    lastSyncTime?: SortOrder
    recordsSynced?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncStatusMinOrderByAggregateInput = {
    id?: SortOrder
    lastSyncTime?: SortOrder
    recordsSynced?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncStatusSumOrderByAggregateInput = {
    recordsSynced?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PayrollEmployeeIdMonthYearCompoundUniqueInput = {
    employeeId: string
    month: number
    year: number
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    totalWorkingDays?: SortOrder
    actualPresentDays?: SortOrder
    lopDays?: SortOrder
    paidDays?: SortOrder
    basicPaid?: SortOrder
    hraPaid?: SortOrder
    conveyancePaid?: SortOrder
    medicalPaid?: SortOrder
    specialPaid?: SortOrder
    allowancesPaid?: SortOrder
    bonus?: SortOrder
    incentives?: SortOrder
    arrears?: SortOrder
    otHours?: SortOrder
    otPay?: SortOrder
    pfDeduction?: SortOrder
    esiDeduction?: SortOrder
    ptDeduction?: SortOrder
    tdsDeduction?: SortOrder
    otherDeductions?: SortOrder
    employerPF?: SortOrder
    employerESI?: SortOrder
    grossSalary?: SortOrder
    totalDeductions?: SortOrder
    netSalary?: SortOrder
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BranchCreateNestedManyWithoutLocationInput = {
    create?: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput> | BranchCreateWithoutLocationInput[] | BranchUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutLocationInput | BranchCreateOrConnectWithoutLocationInput[]
    createMany?: BranchCreateManyLocationInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput> | BranchCreateWithoutLocationInput[] | BranchUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutLocationInput | BranchCreateOrConnectWithoutLocationInput[]
    createMany?: BranchCreateManyLocationInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BranchUpdateManyWithoutLocationNestedInput = {
    create?: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput> | BranchCreateWithoutLocationInput[] | BranchUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutLocationInput | BranchCreateOrConnectWithoutLocationInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutLocationInput | BranchUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: BranchCreateManyLocationInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutLocationInput | BranchUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutLocationInput | BranchUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput> | BranchCreateWithoutLocationInput[] | BranchUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutLocationInput | BranchCreateOrConnectWithoutLocationInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutLocationInput | BranchUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: BranchCreateManyLocationInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutLocationInput | BranchUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutLocationInput | BranchUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutBranchesInput = {
    create?: XOR<LocationCreateWithoutBranchesInput, LocationUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBranchesInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type LocationUpdateOneWithoutBranchesNestedInput = {
    create?: XOR<LocationCreateWithoutBranchesInput, LocationUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutBranchesInput
    upsert?: LocationUpsertWithoutBranchesInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutBranchesInput, LocationUpdateWithoutBranchesInput>, LocationUncheckedUpdateWithoutBranchesInput>
  }

  export type EmployeeUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutBranchInput | EmployeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutBranchInput | EmployeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutBranchInput | EmployeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutBranchInput | EmployeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutBranchInput | EmployeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutBranchInput | EmployeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutManagedDepartmentsInput = {
    create?: XOR<EmployeeCreateWithoutManagedDepartmentsInput, EmployeeUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagedDepartmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutDepartmentsNestedInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    upsert?: BranchUpsertWithoutDepartmentsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDepartmentsInput, BranchUpdateWithoutDepartmentsInput>, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type EmployeeUpdateOneWithoutManagedDepartmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagedDepartmentsInput, EmployeeUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagedDepartmentsInput
    upsert?: EmployeeUpsertWithoutManagedDepartmentsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutManagedDepartmentsInput, EmployeeUpdateWithoutManagedDepartmentsInput>, EmployeeUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutDesignationInput = {
    create?: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput> | EmployeeCreateWithoutDesignationInput[] | EmployeeUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDesignationInput | EmployeeCreateOrConnectWithoutDesignationInput[]
    createMany?: EmployeeCreateManyDesignationInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDesignationInput = {
    create?: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput> | EmployeeCreateWithoutDesignationInput[] | EmployeeUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDesignationInput | EmployeeCreateOrConnectWithoutDesignationInput[]
    createMany?: EmployeeCreateManyDesignationInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput> | EmployeeCreateWithoutDesignationInput[] | EmployeeUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDesignationInput | EmployeeCreateOrConnectWithoutDesignationInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDesignationInput | EmployeeUpsertWithWhereUniqueWithoutDesignationInput[]
    createMany?: EmployeeCreateManyDesignationInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDesignationInput | EmployeeUpdateWithWhereUniqueWithoutDesignationInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDesignationInput | EmployeeUpdateManyWithWhereWithoutDesignationInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput> | EmployeeCreateWithoutDesignationInput[] | EmployeeUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDesignationInput | EmployeeCreateOrConnectWithoutDesignationInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDesignationInput | EmployeeUpsertWithWhereUniqueWithoutDesignationInput[]
    createMany?: EmployeeCreateManyDesignationInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDesignationInput | EmployeeUpdateWithWhereUniqueWithoutDesignationInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDesignationInput | EmployeeUpdateManyWithWhereWithoutDesignationInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput> | EmployeeCreateWithoutCategoryInput[] | EmployeeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCategoryInput | EmployeeCreateOrConnectWithoutCategoryInput[]
    createMany?: EmployeeCreateManyCategoryInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput> | EmployeeCreateWithoutCategoryInput[] | EmployeeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCategoryInput | EmployeeCreateOrConnectWithoutCategoryInput[]
    createMany?: EmployeeCreateManyCategoryInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput> | EmployeeCreateWithoutCategoryInput[] | EmployeeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCategoryInput | EmployeeCreateOrConnectWithoutCategoryInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCategoryInput | EmployeeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EmployeeCreateManyCategoryInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCategoryInput | EmployeeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCategoryInput | EmployeeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput> | EmployeeCreateWithoutCategoryInput[] | EmployeeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCategoryInput | EmployeeCreateOrConnectWithoutCategoryInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCategoryInput | EmployeeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EmployeeCreateManyCategoryInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCategoryInput | EmployeeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCategoryInput | EmployeeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeesInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DesignationCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DesignationCreateWithoutEmployeesInput, DesignationUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutEmployeesInput
    connect?: DesignationWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<CategoryCreateWithoutEmployeesInput, CategoryUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEmployeesInput
    connect?: CategoryWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    connect?: ShiftWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type LeaveEntryCreateNestedManyWithoutManagerInput = {
    create?: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput> | LeaveEntryCreateWithoutManagerInput[] | LeaveEntryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutManagerInput | LeaveEntryCreateOrConnectWithoutManagerInput[]
    createMany?: LeaveEntryCreateManyManagerInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type LeaveEntryCreateNestedManyWithoutCeoInput = {
    create?: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput> | LeaveEntryCreateWithoutCeoInput[] | LeaveEntryUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutCeoInput | LeaveEntryCreateOrConnectWithoutCeoInput[]
    createMany?: LeaveEntryCreateManyCeoInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type AttendanceLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type LeaveEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput> | LeaveEntryCreateWithoutEmployeeInput[] | LeaveEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutEmployeeInput | LeaveEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveEntryCreateManyEmployeeInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type EmployeeShiftCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type LeaveEntryUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput> | LeaveEntryCreateWithoutManagerInput[] | LeaveEntryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutManagerInput | LeaveEntryCreateOrConnectWithoutManagerInput[]
    createMany?: LeaveEntryCreateManyManagerInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type LeaveEntryUncheckedCreateNestedManyWithoutCeoInput = {
    create?: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput> | LeaveEntryCreateWithoutCeoInput[] | LeaveEntryUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutCeoInput | LeaveEntryCreateOrConnectWithoutCeoInput[]
    createMany?: LeaveEntryCreateManyCeoInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput> | LeaveEntryCreateWithoutEmployeeInput[] | LeaveEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutEmployeeInput | LeaveEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveEntryCreateManyEmployeeInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeesInput
    upsert?: BranchUpsertWithoutEmployeesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEmployeesInput, BranchUpdateWithoutEmployeesInput>, BranchUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DesignationUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DesignationCreateWithoutEmployeesInput, DesignationUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutEmployeesInput
    upsert?: DesignationUpsertWithoutEmployeesInput
    disconnect?: DesignationWhereInput | boolean
    delete?: DesignationWhereInput | boolean
    connect?: DesignationWhereUniqueInput
    update?: XOR<XOR<DesignationUpdateToOneWithWhereWithoutEmployeesInput, DesignationUpdateWithoutEmployeesInput>, DesignationUncheckedUpdateWithoutEmployeesInput>
  }

  export type CategoryUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<CategoryCreateWithoutEmployeesInput, CategoryUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEmployeesInput
    upsert?: CategoryUpsertWithoutEmployeesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutEmployeesInput, CategoryUpdateWithoutEmployeesInput>, CategoryUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    upsert?: ShiftUpsertWithoutEmployeesInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutEmployeesInput, ShiftUpdateWithoutEmployeesInput>, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type DepartmentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type LeaveEntryUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput> | LeaveEntryCreateWithoutManagerInput[] | LeaveEntryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutManagerInput | LeaveEntryCreateOrConnectWithoutManagerInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutManagerInput | LeaveEntryUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LeaveEntryCreateManyManagerInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutManagerInput | LeaveEntryUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutManagerInput | LeaveEntryUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type LeaveEntryUpdateManyWithoutCeoNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput> | LeaveEntryCreateWithoutCeoInput[] | LeaveEntryUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutCeoInput | LeaveEntryCreateOrConnectWithoutCeoInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutCeoInput | LeaveEntryUpsertWithWhereUniqueWithoutCeoInput[]
    createMany?: LeaveEntryCreateManyCeoInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutCeoInput | LeaveEntryUpdateWithWhereUniqueWithoutCeoInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutCeoInput | LeaveEntryUpdateManyWithWhereWithoutCeoInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type AttendanceLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type LeaveEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput> | LeaveEntryCreateWithoutEmployeeInput[] | LeaveEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutEmployeeInput | LeaveEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutEmployeeInput | LeaveEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveEntryCreateManyEmployeeInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutEmployeeInput | LeaveEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutEmployeeInput | LeaveEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type EmployeeShiftUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput | EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput> | LeaveEntryCreateWithoutManagerInput[] | LeaveEntryUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutManagerInput | LeaveEntryCreateOrConnectWithoutManagerInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutManagerInput | LeaveEntryUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LeaveEntryCreateManyManagerInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutManagerInput | LeaveEntryUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutManagerInput | LeaveEntryUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput> | LeaveEntryCreateWithoutCeoInput[] | LeaveEntryUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutCeoInput | LeaveEntryCreateOrConnectWithoutCeoInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutCeoInput | LeaveEntryUpsertWithWhereUniqueWithoutCeoInput[]
    createMany?: LeaveEntryCreateManyCeoInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutCeoInput | LeaveEntryUpdateWithWhereUniqueWithoutCeoInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutCeoInput | LeaveEntryUpdateManyWithWhereWithoutCeoInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput> | LeaveEntryCreateWithoutEmployeeInput[] | LeaveEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutEmployeeInput | LeaveEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutEmployeeInput | LeaveEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveEntryCreateManyEmployeeInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutEmployeeInput | LeaveEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutEmployeeInput | LeaveEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput | EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeShiftCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeShiftUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeShiftUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput | EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput | EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutShiftInput | EmployeeShiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput | EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput | EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutShiftInput | EmployeeShiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutEmployeeShiftsInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeShiftsInput, EmployeeUncheckedCreateWithoutEmployeeShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeShiftsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutEmployeeShiftsInput = {
    create?: XOR<ShiftCreateWithoutEmployeeShiftsInput, ShiftUncheckedCreateWithoutEmployeeShiftsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeShiftsInput
    connect?: ShiftWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeShiftsInput, EmployeeUncheckedCreateWithoutEmployeeShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeShiftsInput
    upsert?: EmployeeUpsertWithoutEmployeeShiftsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeShiftsInput, EmployeeUpdateWithoutEmployeeShiftsInput>, EmployeeUncheckedUpdateWithoutEmployeeShiftsInput>
  }

  export type ShiftUpdateOneRequiredWithoutEmployeeShiftsNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeShiftsInput, ShiftUncheckedCreateWithoutEmployeeShiftsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeShiftsInput
    upsert?: ShiftUpsertWithoutEmployeeShiftsInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutEmployeeShiftsInput, ShiftUpdateWithoutEmployeeShiftsInput>, ShiftUncheckedUpdateWithoutEmployeeShiftsInput>
  }

  export type LeaveEntryCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput> | LeaveEntryCreateWithoutLeaveTypeInput[] | LeaveEntryUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutLeaveTypeInput | LeaveEntryCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveEntryCreateManyLeaveTypeInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type LeaveEntryUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput> | LeaveEntryCreateWithoutLeaveTypeInput[] | LeaveEntryUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutLeaveTypeInput | LeaveEntryCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveEntryCreateManyLeaveTypeInputEnvelope
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
  }

  export type LeaveEntryUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput> | LeaveEntryCreateWithoutLeaveTypeInput[] | LeaveEntryUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutLeaveTypeInput | LeaveEntryCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveEntryUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveEntryCreateManyLeaveTypeInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveEntryUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutLeaveTypeInput | LeaveEntryUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type LeaveEntryUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput> | LeaveEntryCreateWithoutLeaveTypeInput[] | LeaveEntryUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveEntryCreateOrConnectWithoutLeaveTypeInput | LeaveEntryCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveEntryUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveEntryUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveEntryCreateManyLeaveTypeInputEnvelope
    set?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    disconnect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    delete?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    connect?: LeaveEntryWhereUniqueInput | LeaveEntryWhereUniqueInput[]
    update?: LeaveEntryUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveEntryUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveEntryUpdateManyWithWhereWithoutLeaveTypeInput | LeaveEntryUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutLeaveEntriesInput = {
    create?: XOR<EmployeeCreateWithoutLeaveEntriesInput, EmployeeUncheckedCreateWithoutLeaveEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveEntriesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutLeaveEntriesInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveEntriesInput, LeaveTypeUncheckedCreateWithoutLeaveEntriesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveEntriesInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutManagerApprovedLeavesInput = {
    create?: XOR<EmployeeCreateWithoutManagerApprovedLeavesInput, EmployeeUncheckedCreateWithoutManagerApprovedLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerApprovedLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutCeoApprovedLeavesInput = {
    create?: XOR<EmployeeCreateWithoutCeoApprovedLeavesInput, EmployeeUncheckedCreateWithoutCeoApprovedLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCeoApprovedLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveEntriesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveEntriesInput, EmployeeUncheckedCreateWithoutLeaveEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveEntriesInput
    upsert?: EmployeeUpsertWithoutLeaveEntriesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveEntriesInput, EmployeeUpdateWithoutLeaveEntriesInput>, EmployeeUncheckedUpdateWithoutLeaveEntriesInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutLeaveEntriesNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveEntriesInput, LeaveTypeUncheckedCreateWithoutLeaveEntriesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveEntriesInput
    upsert?: LeaveTypeUpsertWithoutLeaveEntriesInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutLeaveEntriesInput, LeaveTypeUpdateWithoutLeaveEntriesInput>, LeaveTypeUncheckedUpdateWithoutLeaveEntriesInput>
  }

  export type EmployeeUpdateOneWithoutManagerApprovedLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerApprovedLeavesInput, EmployeeUncheckedCreateWithoutManagerApprovedLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerApprovedLeavesInput
    upsert?: EmployeeUpsertWithoutManagerApprovedLeavesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutManagerApprovedLeavesInput, EmployeeUpdateWithoutManagerApprovedLeavesInput>, EmployeeUncheckedUpdateWithoutManagerApprovedLeavesInput>
  }

  export type EmployeeUpdateOneWithoutCeoApprovedLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutCeoApprovedLeavesInput, EmployeeUncheckedCreateWithoutCeoApprovedLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCeoApprovedLeavesInput
    upsert?: EmployeeUpsertWithoutCeoApprovedLeavesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutCeoApprovedLeavesInput, EmployeeUpdateWithoutCeoApprovedLeavesInput>, EmployeeUncheckedUpdateWithoutCeoApprovedLeavesInput>
  }

  export type DeviceUserCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type RawDeviceLogCreateNestedManyWithoutDeviceInput = {
    create?: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput> | RawDeviceLogCreateWithoutDeviceInput[] | RawDeviceLogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: RawDeviceLogCreateOrConnectWithoutDeviceInput | RawDeviceLogCreateOrConnectWithoutDeviceInput[]
    createMany?: RawDeviceLogCreateManyDeviceInputEnvelope
    connect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
  }

  export type RawDeviceLogUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput> | RawDeviceLogCreateWithoutDeviceInput[] | RawDeviceLogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: RawDeviceLogCreateOrConnectWithoutDeviceInput | RawDeviceLogCreateOrConnectWithoutDeviceInput[]
    createMany?: RawDeviceLogCreateManyDeviceInputEnvelope
    connect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceUserUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutDeviceInput | DeviceUserUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutDeviceInput | DeviceUserUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutDeviceInput | DeviceUserUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type RawDeviceLogUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput> | RawDeviceLogCreateWithoutDeviceInput[] | RawDeviceLogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: RawDeviceLogCreateOrConnectWithoutDeviceInput | RawDeviceLogCreateOrConnectWithoutDeviceInput[]
    upsert?: RawDeviceLogUpsertWithWhereUniqueWithoutDeviceInput | RawDeviceLogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: RawDeviceLogCreateManyDeviceInputEnvelope
    set?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    disconnect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    delete?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    connect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    update?: RawDeviceLogUpdateWithWhereUniqueWithoutDeviceInput | RawDeviceLogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: RawDeviceLogUpdateManyWithWhereWithoutDeviceInput | RawDeviceLogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: RawDeviceLogScalarWhereInput | RawDeviceLogScalarWhereInput[]
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput> | DeviceUserCreateWithoutDeviceInput[] | DeviceUserUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceUserCreateOrConnectWithoutDeviceInput | DeviceUserCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceUserUpsertWithWhereUniqueWithoutDeviceInput | DeviceUserUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    disconnect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    delete?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    connect?: DeviceUserWhereUniqueInput | DeviceUserWhereUniqueInput[]
    update?: DeviceUserUpdateWithWhereUniqueWithoutDeviceInput | DeviceUserUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceUserUpdateManyWithWhereWithoutDeviceInput | DeviceUserUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
  }

  export type RawDeviceLogUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput> | RawDeviceLogCreateWithoutDeviceInput[] | RawDeviceLogUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: RawDeviceLogCreateOrConnectWithoutDeviceInput | RawDeviceLogCreateOrConnectWithoutDeviceInput[]
    upsert?: RawDeviceLogUpsertWithWhereUniqueWithoutDeviceInput | RawDeviceLogUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: RawDeviceLogCreateManyDeviceInputEnvelope
    set?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    disconnect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    delete?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    connect?: RawDeviceLogWhereUniqueInput | RawDeviceLogWhereUniqueInput[]
    update?: RawDeviceLogUpdateWithWhereUniqueWithoutDeviceInput | RawDeviceLogUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: RawDeviceLogUpdateManyWithWhereWithoutDeviceInput | RawDeviceLogUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: RawDeviceLogScalarWhereInput | RawDeviceLogScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutDeviceUsersInput = {
    create?: XOR<DeviceCreateWithoutDeviceUsersInput, DeviceUncheckedCreateWithoutDeviceUsersInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceUsersInput
    connect?: DeviceWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDeviceUsersNestedInput = {
    create?: XOR<DeviceCreateWithoutDeviceUsersInput, DeviceUncheckedCreateWithoutDeviceUsersInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDeviceUsersInput
    upsert?: DeviceUpsertWithoutDeviceUsersInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDeviceUsersInput, DeviceUpdateWithoutDeviceUsersInput>, DeviceUncheckedUpdateWithoutDeviceUsersInput>
  }

  export type DeviceCreateNestedOneWithoutRawDeviceLogsInput = {
    create?: XOR<DeviceCreateWithoutRawDeviceLogsInput, DeviceUncheckedCreateWithoutRawDeviceLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutRawDeviceLogsInput
    connect?: DeviceWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutRawDeviceLogsNestedInput = {
    create?: XOR<DeviceCreateWithoutRawDeviceLogsInput, DeviceUncheckedCreateWithoutRawDeviceLogsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutRawDeviceLogsInput
    upsert?: DeviceUpsertWithoutRawDeviceLogsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutRawDeviceLogsInput, DeviceUpdateWithoutRawDeviceLogsInput>, DeviceUncheckedUpdateWithoutRawDeviceLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceLogsInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogsInput
    upsert?: EmployeeUpsertWithoutAttendanceLogsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceLogsInput, EmployeeUpdateWithoutAttendanceLogsInput>, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    upsert?: EmployeeUpsertWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollsInput, EmployeeUpdateWithoutPayrollsInput>, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type BranchCreateWithoutLocationInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    departments?: DepartmentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutLocationInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput>
  }

  export type BranchCreateManyLocationInputEnvelope = {
    data: BranchCreateManyLocationInput | BranchCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutLocationInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutLocationInput, BranchUncheckedUpdateWithoutLocationInput>
    create: XOR<BranchCreateWithoutLocationInput, BranchUncheckedCreateWithoutLocationInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutLocationInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutLocationInput, BranchUncheckedUpdateWithoutLocationInput>
  }

  export type BranchUpdateManyWithWhereWithoutLocationInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutLocationInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    locationId?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type LocationCreateWithoutBranchesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zipCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zipCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutBranchesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutBranchesInput, LocationUncheckedCreateWithoutBranchesInput>
  }

  export type EmployeeCreateWithoutBranchInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutBranchInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeCreateManyBranchInputEnvelope = {
    data: EmployeeCreateManyBranchInput | EmployeeCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutBranchInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: EmployeeCreateNestedOneWithoutManagedDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    code: string
    managerId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentCreateManyBranchInputEnvelope = {
    data: DepartmentCreateManyBranchInput | DepartmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutBranchesInput = {
    update: XOR<LocationUpdateWithoutBranchesInput, LocationUncheckedUpdateWithoutBranchesInput>
    create: XOR<LocationCreateWithoutBranchesInput, LocationUncheckedCreateWithoutBranchesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutBranchesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutBranchesInput, LocationUncheckedUpdateWithoutBranchesInput>
  }

  export type LocationUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutBranchInput, EmployeeUncheckedUpdateWithoutBranchInput>
    create: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutBranchInput, EmployeeUncheckedUpdateWithoutBranchInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutBranchInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutBranchInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeCode?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    branchId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designationId?: StringNullableFilter<"Employee"> | string | null
    categoryId?: StringNullableFilter<"Employee"> | string | null
    shiftId?: StringNullableFilter<"Employee"> | string | null
    deviceUserId?: StringNullableFilter<"Employee"> | string | null
    sourceEmployeeId?: StringNullableFilter<"Employee"> | string | null
    dateOfJoining?: DateTimeNullableFilter<"Employee"> | Date | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    basicSalary?: FloatFilter<"Employee"> | number
    hra?: FloatFilter<"Employee"> | number
    conveyance?: FloatFilter<"Employee"> | number
    medicalAllowance?: FloatFilter<"Employee"> | number
    specialAllowance?: FloatFilter<"Employee"> | number
    otherAllowances?: FloatFilter<"Employee"> | number
    standardDeductions?: FloatFilter<"Employee"> | number
    bankName?: StringNullableFilter<"Employee"> | string | null
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    ifscCode?: StringNullableFilter<"Employee"> | string | null
    panNumber?: StringNullableFilter<"Employee"> | string | null
    aadhaarNumber?: StringNullableFilter<"Employee"> | string | null
    isPFEnabled?: BoolFilter<"Employee"> | boolean
    isESIEnabled?: BoolFilter<"Employee"> | boolean
    isPTEnabled?: BoolFilter<"Employee"> | boolean
    isOTEnabled?: BoolFilter<"Employee"> | boolean
    otRateMultiplier?: FloatFilter<"Employee"> | number
  }

  export type DepartmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutBranchInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    branchId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type BranchCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutBranchesInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    code: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDepartmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
  }

  export type EmployeeCreateWithoutManagedDepartmentsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutManagedDepartmentsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutManagedDepartmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutManagedDepartmentsInput, EmployeeUncheckedCreateWithoutManagedDepartmentsInput>
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutDepartmentsInput = {
    update: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type BranchUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutBranchesNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EmployeeUpsertWithoutManagedDepartmentsInput = {
    update: XOR<EmployeeUpdateWithoutManagedDepartmentsInput, EmployeeUncheckedUpdateWithoutManagedDepartmentsInput>
    create: XOR<EmployeeCreateWithoutManagedDepartmentsInput, EmployeeUncheckedCreateWithoutManagedDepartmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutManagedDepartmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutManagedDepartmentsInput, EmployeeUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type EmployeeUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EmployeeCreateWithoutDesignationInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDesignationInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDesignationInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput>
  }

  export type EmployeeCreateManyDesignationInputEnvelope = {
    data: EmployeeCreateManyDesignationInput | EmployeeCreateManyDesignationInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDesignationInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDesignationInput, EmployeeUncheckedUpdateWithoutDesignationInput>
    create: XOR<EmployeeCreateWithoutDesignationInput, EmployeeUncheckedCreateWithoutDesignationInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDesignationInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDesignationInput, EmployeeUncheckedUpdateWithoutDesignationInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDesignationInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDesignationInput>
  }

  export type EmployeeCreateWithoutCategoryInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCategoryInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCategoryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput>
  }

  export type EmployeeCreateManyCategoryInputEnvelope = {
    data: EmployeeCreateManyCategoryInput | EmployeeCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutCategoryInput, EmployeeUncheckedUpdateWithoutCategoryInput>
    create: XOR<EmployeeCreateWithoutCategoryInput, EmployeeUncheckedCreateWithoutCategoryInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutCategoryInput, EmployeeUncheckedUpdateWithoutCategoryInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutCategoryInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BranchCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutBranchesInput
    departments?: DepartmentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEmployeesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutDepartmentsInput
    manager?: EmployeeCreateNestedOneWithoutManagedDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    branchId?: string | null
    managerId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type DesignationCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationCreateOrConnectWithoutEmployeesInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutEmployeesInput, DesignationUncheckedCreateWithoutEmployeesInput>
  }

  export type CategoryCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutEmployeesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEmployeesInput, CategoryUncheckedCreateWithoutEmployeesInput>
  }

  export type ShiftCreateWithoutEmployeesInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutEmployeesInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    username: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    username: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type DepartmentCreateWithoutManagerInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    code: string
    branchId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentCreateManyManagerInputEnvelope = {
    data: DepartmentCreateManyManagerInput | DepartmentCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LeaveEntryCreateWithoutManagerInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveEntriesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveEntriesInput
    ceo?: EmployeeCreateNestedOneWithoutCeoApprovedLeavesInput
  }

  export type LeaveEntryUncheckedCreateWithoutManagerInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateOrConnectWithoutManagerInput = {
    where: LeaveEntryWhereUniqueInput
    create: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput>
  }

  export type LeaveEntryCreateManyManagerInputEnvelope = {
    data: LeaveEntryCreateManyManagerInput | LeaveEntryCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LeaveEntryCreateWithoutCeoInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveEntriesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveEntriesInput
    manager?: EmployeeCreateNestedOneWithoutManagerApprovedLeavesInput
  }

  export type LeaveEntryUncheckedCreateWithoutCeoInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateOrConnectWithoutCeoInput = {
    where: LeaveEntryWhereUniqueInput
    create: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput>
  }

  export type LeaveEntryCreateManyCeoInputEnvelope = {
    data: LeaveEntryCreateManyCeoInput | LeaveEntryCreateManyCeoInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceLogCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogCreateManyEmployeeInputEnvelope = {
    data: AttendanceLogCreateManyEmployeeInput | AttendanceLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveEntryCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveEntriesInput
    manager?: EmployeeCreateNestedOneWithoutManagerApprovedLeavesInput
    ceo?: EmployeeCreateNestedOneWithoutCeoApprovedLeavesInput
  }

  export type LeaveEntryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateOrConnectWithoutEmployeeInput = {
    where: LeaveEntryWhereUniqueInput
    create: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveEntryCreateManyEmployeeInputEnvelope = {
    data: LeaveEntryCreateManyEmployeeInput | LeaveEntryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeShiftCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shift: ShiftCreateNestedOneWithoutEmployeeShiftsInput
  }

  export type EmployeeShiftUncheckedCreateWithoutEmployeeInput = {
    id?: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeShiftCreateManyEmployeeInputEnvelope = {
    data: EmployeeShiftCreateManyEmployeeInput | EmployeeShiftCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutEmployeeInput = {
    id?: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUncheckedCreateWithoutEmployeeInput = {
    id?: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollCreateManyEmployeeInputEnvelope = {
    data: PayrollCreateManyEmployeeInput | PayrollCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutEmployeesInput = {
    update: XOR<BranchUpdateWithoutEmployeesInput, BranchUncheckedUpdateWithoutEmployeesInput>
    create: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEmployeesInput, BranchUncheckedUpdateWithoutEmployeesInput>
  }

  export type BranchUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutBranchesNestedInput
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutDepartmentsNestedInput
    manager?: EmployeeUpdateOneWithoutManagedDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUpsertWithoutEmployeesInput = {
    update: XOR<DesignationUpdateWithoutEmployeesInput, DesignationUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DesignationCreateWithoutEmployeesInput, DesignationUncheckedCreateWithoutEmployeesInput>
    where?: DesignationWhereInput
  }

  export type DesignationUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DesignationWhereInput
    data: XOR<DesignationUpdateWithoutEmployeesInput, DesignationUncheckedUpdateWithoutEmployeesInput>
  }

  export type DesignationUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutEmployeesInput = {
    update: XOR<CategoryUpdateWithoutEmployeesInput, CategoryUncheckedUpdateWithoutEmployeesInput>
    create: XOR<CategoryCreateWithoutEmployeesInput, CategoryUncheckedCreateWithoutEmployeesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutEmployeesInput, CategoryUncheckedUpdateWithoutEmployeesInput>
  }

  export type CategoryUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpsertWithoutEmployeesInput = {
    update: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeShifts?: EmployeeShiftUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutManagerInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutManagerInput>
  }

  export type LeaveEntryUpsertWithWhereUniqueWithoutManagerInput = {
    where: LeaveEntryWhereUniqueInput
    update: XOR<LeaveEntryUpdateWithoutManagerInput, LeaveEntryUncheckedUpdateWithoutManagerInput>
    create: XOR<LeaveEntryCreateWithoutManagerInput, LeaveEntryUncheckedCreateWithoutManagerInput>
  }

  export type LeaveEntryUpdateWithWhereUniqueWithoutManagerInput = {
    where: LeaveEntryWhereUniqueInput
    data: XOR<LeaveEntryUpdateWithoutManagerInput, LeaveEntryUncheckedUpdateWithoutManagerInput>
  }

  export type LeaveEntryUpdateManyWithWhereWithoutManagerInput = {
    where: LeaveEntryScalarWhereInput
    data: XOR<LeaveEntryUpdateManyMutationInput, LeaveEntryUncheckedUpdateManyWithoutManagerInput>
  }

  export type LeaveEntryScalarWhereInput = {
    AND?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
    OR?: LeaveEntryScalarWhereInput[]
    NOT?: LeaveEntryScalarWhereInput | LeaveEntryScalarWhereInput[]
    id?: StringFilter<"LeaveEntry"> | string
    employeeId?: StringFilter<"LeaveEntry"> | string
    leaveTypeId?: StringFilter<"LeaveEntry"> | string
    startDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaveEntry"> | Date | string
    days?: FloatFilter<"LeaveEntry"> | number
    reason?: StringNullableFilter<"LeaveEntry"> | string | null
    status?: StringFilter<"LeaveEntry"> | string
    managerApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    managerApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    managerId?: StringNullableFilter<"LeaveEntry"> | string | null
    ceoApproval?: BoolNullableFilter<"LeaveEntry"> | boolean | null
    ceoApprovedAt?: DateTimeNullableFilter<"LeaveEntry"> | Date | string | null
    ceoId?: StringNullableFilter<"LeaveEntry"> | string | null
    createdAt?: DateTimeFilter<"LeaveEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveEntry"> | Date | string
  }

  export type LeaveEntryUpsertWithWhereUniqueWithoutCeoInput = {
    where: LeaveEntryWhereUniqueInput
    update: XOR<LeaveEntryUpdateWithoutCeoInput, LeaveEntryUncheckedUpdateWithoutCeoInput>
    create: XOR<LeaveEntryCreateWithoutCeoInput, LeaveEntryUncheckedCreateWithoutCeoInput>
  }

  export type LeaveEntryUpdateWithWhereUniqueWithoutCeoInput = {
    where: LeaveEntryWhereUniqueInput
    data: XOR<LeaveEntryUpdateWithoutCeoInput, LeaveEntryUncheckedUpdateWithoutCeoInput>
  }

  export type LeaveEntryUpdateManyWithWhereWithoutCeoInput = {
    where: LeaveEntryScalarWhereInput
    data: XOR<LeaveEntryUpdateManyMutationInput, LeaveEntryUncheckedUpdateManyWithoutCeoInput>
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceLogScalarWhereInput = {
    AND?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    OR?: AttendanceLogScalarWhereInput[]
    NOT?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    id?: StringFilter<"AttendanceLog"> | string
    employeeId?: StringFilter<"AttendanceLog"> | string
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    firstIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lastOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    workingHours?: FloatNullableFilter<"AttendanceLog"> | number | null
    shiftStart?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    shiftEnd?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    lateArrival?: IntFilter<"AttendanceLog"> | number
    earlyDeparture?: IntFilter<"AttendanceLog"> | number
    status?: StringFilter<"AttendanceLog"> | string
    totalPunches?: IntFilter<"AttendanceLog"> | number
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceLog"> | Date | string
  }

  export type LeaveEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveEntryWhereUniqueInput
    update: XOR<LeaveEntryUpdateWithoutEmployeeInput, LeaveEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveEntryCreateWithoutEmployeeInput, LeaveEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveEntryWhereUniqueInput
    data: XOR<LeaveEntryUpdateWithoutEmployeeInput, LeaveEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveEntryScalarWhereInput
    data: XOR<LeaveEntryUpdateManyMutationInput, LeaveEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    update: XOR<EmployeeShiftUpdateWithoutEmployeeInput, EmployeeShiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    data: XOR<EmployeeShiftUpdateWithoutEmployeeInput, EmployeeShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeShiftScalarWhereInput
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeShiftScalarWhereInput = {
    AND?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    OR?: EmployeeShiftScalarWhereInput[]
    NOT?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    id?: StringFilter<"EmployeeShift"> | string
    employeeId?: StringFilter<"EmployeeShift"> | string
    shiftId?: StringFilter<"EmployeeShift"> | string
    startDate?: DateTimeFilter<"EmployeeShift"> | Date | string
    endDate?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeShift"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeShift"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    totalWorkingDays?: IntFilter<"Payroll"> | number
    actualPresentDays?: FloatFilter<"Payroll"> | number
    lopDays?: FloatFilter<"Payroll"> | number
    paidDays?: FloatFilter<"Payroll"> | number
    basicPaid?: FloatFilter<"Payroll"> | number
    hraPaid?: FloatFilter<"Payroll"> | number
    conveyancePaid?: FloatFilter<"Payroll"> | number
    medicalPaid?: FloatFilter<"Payroll"> | number
    specialPaid?: FloatFilter<"Payroll"> | number
    allowancesPaid?: FloatFilter<"Payroll"> | number
    bonus?: FloatFilter<"Payroll"> | number
    incentives?: FloatFilter<"Payroll"> | number
    arrears?: FloatFilter<"Payroll"> | number
    otHours?: FloatFilter<"Payroll"> | number
    otPay?: FloatFilter<"Payroll"> | number
    pfDeduction?: FloatFilter<"Payroll"> | number
    esiDeduction?: FloatFilter<"Payroll"> | number
    ptDeduction?: FloatFilter<"Payroll"> | number
    tdsDeduction?: FloatFilter<"Payroll"> | number
    otherDeductions?: FloatFilter<"Payroll"> | number
    employerPF?: FloatFilter<"Payroll"> | number
    employerESI?: FloatFilter<"Payroll"> | number
    grossSalary?: FloatFilter<"Payroll"> | number
    totalDeductions?: FloatFilter<"Payroll"> | number
    netSalary?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    remarks?: StringNullableFilter<"Payroll"> | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type EmployeeCreateWithoutShiftInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeCreateManyShiftInputEnvelope = {
    data: EmployeeCreateManyShiftInput | EmployeeCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeShiftCreateWithoutShiftInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeeShiftsInput
  }

  export type EmployeeShiftUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftCreateOrConnectWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeShiftCreateManyShiftInputEnvelope = {
    data: EmployeeShiftCreateManyShiftInput | EmployeeShiftCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    update: XOR<EmployeeShiftUpdateWithoutShiftInput, EmployeeShiftUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    data: XOR<EmployeeShiftUpdateWithoutShiftInput, EmployeeShiftUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeShiftUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeShiftScalarWhereInput
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeCreateWithoutEmployeeShiftsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeShiftsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeShiftsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeShiftsInput, EmployeeUncheckedCreateWithoutEmployeeShiftsInput>
  }

  export type ShiftCreateWithoutEmployeeShiftsInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutEmployeeShiftsInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    gracePeriodIn?: number
    gracePeriodOut?: number
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutEmployeeShiftsInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeeShiftsInput, ShiftUncheckedCreateWithoutEmployeeShiftsInput>
  }

  export type EmployeeUpsertWithoutEmployeeShiftsInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeShiftsInput, EmployeeUncheckedUpdateWithoutEmployeeShiftsInput>
    create: XOR<EmployeeCreateWithoutEmployeeShiftsInput, EmployeeUncheckedCreateWithoutEmployeeShiftsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeShiftsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeShiftsInput, EmployeeUncheckedUpdateWithoutEmployeeShiftsInput>
  }

  export type EmployeeUpdateWithoutEmployeeShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ShiftUpsertWithoutEmployeeShiftsInput = {
    update: XOR<ShiftUpdateWithoutEmployeeShiftsInput, ShiftUncheckedUpdateWithoutEmployeeShiftsInput>
    create: XOR<ShiftCreateWithoutEmployeeShiftsInput, ShiftUncheckedCreateWithoutEmployeeShiftsInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutEmployeeShiftsInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutEmployeeShiftsInput, ShiftUncheckedUpdateWithoutEmployeeShiftsInput>
  }

  export type ShiftUpdateWithoutEmployeeShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeeShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    gracePeriodIn?: IntFieldUpdateOperationsInput | number
    gracePeriodOut?: IntFieldUpdateOperationsInput | number
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type LeaveEntryCreateWithoutLeaveTypeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveEntriesInput
    manager?: EmployeeCreateNestedOneWithoutManagerApprovedLeavesInput
    ceo?: EmployeeCreateNestedOneWithoutCeoApprovedLeavesInput
  }

  export type LeaveEntryUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveEntryWhereUniqueInput
    create: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveEntryCreateManyLeaveTypeInputEnvelope = {
    data: LeaveEntryCreateManyLeaveTypeInput | LeaveEntryCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveEntryUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveEntryWhereUniqueInput
    update: XOR<LeaveEntryUpdateWithoutLeaveTypeInput, LeaveEntryUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveEntryCreateWithoutLeaveTypeInput, LeaveEntryUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveEntryUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveEntryWhereUniqueInput
    data: XOR<LeaveEntryUpdateWithoutLeaveTypeInput, LeaveEntryUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveEntryUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveEntryScalarWhereInput
    data: XOR<LeaveEntryUpdateManyMutationInput, LeaveEntryUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type EmployeeCreateWithoutLeaveEntriesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveEntriesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveEntriesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveEntriesInput, EmployeeUncheckedCreateWithoutLeaveEntriesInput>
  }

  export type LeaveTypeCreateWithoutLeaveEntriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isPaid?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeUncheckedCreateWithoutLeaveEntriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isPaid?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeCreateOrConnectWithoutLeaveEntriesInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutLeaveEntriesInput, LeaveTypeUncheckedCreateWithoutLeaveEntriesInput>
  }

  export type EmployeeCreateWithoutManagerApprovedLeavesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutManagerApprovedLeavesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutManagerApprovedLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutManagerApprovedLeavesInput, EmployeeUncheckedCreateWithoutManagerApprovedLeavesInput>
  }

  export type EmployeeCreateWithoutCeoApprovedLeavesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCeoApprovedLeavesInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCeoApprovedLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCeoApprovedLeavesInput, EmployeeUncheckedCreateWithoutCeoApprovedLeavesInput>
  }

  export type EmployeeUpsertWithoutLeaveEntriesInput = {
    update: XOR<EmployeeUpdateWithoutLeaveEntriesInput, EmployeeUncheckedUpdateWithoutLeaveEntriesInput>
    create: XOR<EmployeeCreateWithoutLeaveEntriesInput, EmployeeUncheckedCreateWithoutLeaveEntriesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveEntriesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveEntriesInput, EmployeeUncheckedUpdateWithoutLeaveEntriesInput>
  }

  export type EmployeeUpdateWithoutLeaveEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveTypeUpsertWithoutLeaveEntriesInput = {
    update: XOR<LeaveTypeUpdateWithoutLeaveEntriesInput, LeaveTypeUncheckedUpdateWithoutLeaveEntriesInput>
    create: XOR<LeaveTypeCreateWithoutLeaveEntriesInput, LeaveTypeUncheckedCreateWithoutLeaveEntriesInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutLeaveEntriesInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutLeaveEntriesInput, LeaveTypeUncheckedUpdateWithoutLeaveEntriesInput>
  }

  export type LeaveTypeUpdateWithoutLeaveEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUncheckedUpdateWithoutLeaveEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutManagerApprovedLeavesInput = {
    update: XOR<EmployeeUpdateWithoutManagerApprovedLeavesInput, EmployeeUncheckedUpdateWithoutManagerApprovedLeavesInput>
    create: XOR<EmployeeCreateWithoutManagerApprovedLeavesInput, EmployeeUncheckedCreateWithoutManagerApprovedLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutManagerApprovedLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutManagerApprovedLeavesInput, EmployeeUncheckedUpdateWithoutManagerApprovedLeavesInput>
  }

  export type EmployeeUpdateWithoutManagerApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutManagerApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUpsertWithoutCeoApprovedLeavesInput = {
    update: XOR<EmployeeUpdateWithoutCeoApprovedLeavesInput, EmployeeUncheckedUpdateWithoutCeoApprovedLeavesInput>
    create: XOR<EmployeeCreateWithoutCeoApprovedLeavesInput, EmployeeUncheckedCreateWithoutCeoApprovedLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutCeoApprovedLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutCeoApprovedLeavesInput, EmployeeUncheckedUpdateWithoutCeoApprovedLeavesInput>
  }

  export type EmployeeUpdateWithoutCeoApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCeoApprovedLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DeviceUserCreateWithoutDeviceInput = {
    id?: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUserUncheckedCreateWithoutDeviceInput = {
    id?: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUserCreateOrConnectWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserCreateManyDeviceInputEnvelope = {
    data: DeviceUserCreateManyDeviceInput | DeviceUserCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type RawDeviceLogCreateWithoutDeviceInput = {
    id?: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
  }

  export type RawDeviceLogUncheckedCreateWithoutDeviceInput = {
    id?: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
  }

  export type RawDeviceLogCreateOrConnectWithoutDeviceInput = {
    where: RawDeviceLogWhereUniqueInput
    create: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput>
  }

  export type RawDeviceLogCreateManyDeviceInputEnvelope = {
    data: RawDeviceLogCreateManyDeviceInput | RawDeviceLogCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceUserScalarWhereInput = {
    AND?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
    OR?: DeviceUserScalarWhereInput[]
    NOT?: DeviceUserScalarWhereInput | DeviceUserScalarWhereInput[]
    id?: StringFilter<"DeviceUser"> | string
    deviceId?: StringFilter<"DeviceUser"> | string
    deviceUserId?: StringFilter<"DeviceUser"> | string
    employeeId?: StringNullableFilter<"DeviceUser"> | string | null
    name?: StringNullableFilter<"DeviceUser"> | string | null
    createdAt?: DateTimeFilter<"DeviceUser"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceUser"> | Date | string
  }

  export type RawDeviceLogUpsertWithWhereUniqueWithoutDeviceInput = {
    where: RawDeviceLogWhereUniqueInput
    update: XOR<RawDeviceLogUpdateWithoutDeviceInput, RawDeviceLogUncheckedUpdateWithoutDeviceInput>
    create: XOR<RawDeviceLogCreateWithoutDeviceInput, RawDeviceLogUncheckedCreateWithoutDeviceInput>
  }

  export type RawDeviceLogUpdateWithWhereUniqueWithoutDeviceInput = {
    where: RawDeviceLogWhereUniqueInput
    data: XOR<RawDeviceLogUpdateWithoutDeviceInput, RawDeviceLogUncheckedUpdateWithoutDeviceInput>
  }

  export type RawDeviceLogUpdateManyWithWhereWithoutDeviceInput = {
    where: RawDeviceLogScalarWhereInput
    data: XOR<RawDeviceLogUpdateManyMutationInput, RawDeviceLogUncheckedUpdateManyWithoutDeviceInput>
  }

  export type RawDeviceLogScalarWhereInput = {
    AND?: RawDeviceLogScalarWhereInput | RawDeviceLogScalarWhereInput[]
    OR?: RawDeviceLogScalarWhereInput[]
    NOT?: RawDeviceLogScalarWhereInput | RawDeviceLogScalarWhereInput[]
    id?: StringFilter<"RawDeviceLog"> | string
    deviceId?: StringFilter<"RawDeviceLog"> | string
    userId?: StringFilter<"RawDeviceLog"> | string
    punchTime?: DateTimeFilter<"RawDeviceLog"> | Date | string
    punchType?: StringNullableFilter<"RawDeviceLog"> | string | null
    isProcessed?: BoolFilter<"RawDeviceLog"> | boolean
    createdAt?: DateTimeFilter<"RawDeviceLog"> | Date | string
  }

  export type DeviceCreateWithoutDeviceUsersInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rawDeviceLogs?: RawDeviceLogCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDeviceUsersInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rawDeviceLogs?: RawDeviceLogUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDeviceUsersInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDeviceUsersInput, DeviceUncheckedCreateWithoutDeviceUsersInput>
  }

  export type DeviceUpsertWithoutDeviceUsersInput = {
    update: XOR<DeviceUpdateWithoutDeviceUsersInput, DeviceUncheckedUpdateWithoutDeviceUsersInput>
    create: XOR<DeviceCreateWithoutDeviceUsersInput, DeviceUncheckedCreateWithoutDeviceUsersInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDeviceUsersInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDeviceUsersInput, DeviceUncheckedUpdateWithoutDeviceUsersInput>
  }

  export type DeviceUpdateWithoutDeviceUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawDeviceLogs?: RawDeviceLogUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDeviceUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rawDeviceLogs?: RawDeviceLogUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutRawDeviceLogsInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceUsers?: DeviceUserCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutRawDeviceLogsInput = {
    id?: string
    deviceId: string
    name: string
    ipAddress?: string | null
    port?: number | null
    location?: string | null
    status?: string
    lastConnected?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceUsers?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutRawDeviceLogsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutRawDeviceLogsInput, DeviceUncheckedCreateWithoutRawDeviceLogsInput>
  }

  export type DeviceUpsertWithoutRawDeviceLogsInput = {
    update: XOR<DeviceUpdateWithoutRawDeviceLogsInput, DeviceUncheckedUpdateWithoutRawDeviceLogsInput>
    create: XOR<DeviceCreateWithoutRawDeviceLogsInput, DeviceUncheckedCreateWithoutRawDeviceLogsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutRawDeviceLogsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutRawDeviceLogsInput, DeviceUncheckedUpdateWithoutRawDeviceLogsInput>
  }

  export type DeviceUpdateWithoutRawDeviceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceUsers?: DeviceUserUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutRawDeviceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnected?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceUsers?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type EmployeeCreateWithoutAttendanceLogsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceLogsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
  }

  export type EmployeeUpsertWithoutAttendanceLogsInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceLogsInput, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
    create: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceLogsInput, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type EmployeeUpdateWithoutAttendanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutPayrollsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    designation?: DesignationCreateNestedOneWithoutEmployeesInput
    category?: CategoryCreateNestedOneWithoutEmployeesInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollsInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    managerApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutManagerInput
    ceoApprovedLeaves?: LeaveEntryUncheckedCreateNestedManyWithoutCeoInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaveEntries?: LeaveEntryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeShifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayrollsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
  }

  export type EmployeeUpsertWithoutPayrollsInput = {
    update: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type EmployeeUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type BranchCreateManyLocationInput = {
    id?: string
    name: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyBranchInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type DepartmentCreateManyBranchInput = {
    id?: string
    name: string
    code: string
    managerId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type DepartmentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: EmployeeUpdateOneWithoutManagedDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    designationId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeCreateManyDesignationInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    categoryId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type EmployeeUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeCreateManyCategoryInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    shiftId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type EmployeeUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type DepartmentCreateManyManagerInput = {
    id?: string
    name: string
    code: string
    branchId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateManyManagerInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateManyCeoInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    firstIn?: Date | string | null
    lastOut?: Date | string | null
    workingHours?: number | null
    shiftStart?: Date | string | null
    shiftEnd?: Date | string | null
    lateArrival?: number
    earlyDeparture?: number
    status?: string
    totalPunches?: number
    rawData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryCreateManyEmployeeInput = {
    id?: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftCreateManyEmployeeInput = {
    id?: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyEmployeeInput = {
    id?: string
    month: number
    year: number
    totalWorkingDays: number
    actualPresentDays: number
    lopDays?: number
    paidDays: number
    basicPaid: number
    hraPaid: number
    conveyancePaid?: number
    medicalPaid?: number
    specialPaid?: number
    allowancesPaid: number
    bonus?: number
    incentives?: number
    arrears?: number
    otHours?: number
    otPay?: number
    pfDeduction?: number
    esiDeduction?: number
    ptDeduction?: number
    tdsDeduction?: number
    otherDeductions?: number
    employerPF?: number
    employerESI?: number
    grossSalary: number
    totalDeductions: number
    netSalary: number
    status?: string
    remarks?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    ceo?: EmployeeUpdateOneWithoutCeoApprovedLeavesNestedInput
  }

  export type LeaveEntryUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUpdateWithoutCeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    manager?: EmployeeUpdateOneWithoutManagerApprovedLeavesNestedInput
  }

  export type LeaveEntryUncheckedUpdateWithoutCeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUncheckedUpdateManyWithoutCeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    firstIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    shiftStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lateArrival?: IntFieldUpdateOperationsInput | number
    earlyDeparture?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalPunches?: IntFieldUpdateOperationsInput | number
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    manager?: EmployeeUpdateOneWithoutManagerApprovedLeavesNestedInput
    ceo?: EmployeeUpdateOneWithoutCeoApprovedLeavesNestedInput
  }

  export type LeaveEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: ShiftUpdateOneRequiredWithoutEmployeeShiftsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    totalWorkingDays?: IntFieldUpdateOperationsInput | number
    actualPresentDays?: FloatFieldUpdateOperationsInput | number
    lopDays?: FloatFieldUpdateOperationsInput | number
    paidDays?: FloatFieldUpdateOperationsInput | number
    basicPaid?: FloatFieldUpdateOperationsInput | number
    hraPaid?: FloatFieldUpdateOperationsInput | number
    conveyancePaid?: FloatFieldUpdateOperationsInput | number
    medicalPaid?: FloatFieldUpdateOperationsInput | number
    specialPaid?: FloatFieldUpdateOperationsInput | number
    allowancesPaid?: FloatFieldUpdateOperationsInput | number
    bonus?: FloatFieldUpdateOperationsInput | number
    incentives?: FloatFieldUpdateOperationsInput | number
    arrears?: FloatFieldUpdateOperationsInput | number
    otHours?: FloatFieldUpdateOperationsInput | number
    otPay?: FloatFieldUpdateOperationsInput | number
    pfDeduction?: FloatFieldUpdateOperationsInput | number
    esiDeduction?: FloatFieldUpdateOperationsInput | number
    ptDeduction?: FloatFieldUpdateOperationsInput | number
    tdsDeduction?: FloatFieldUpdateOperationsInput | number
    otherDeductions?: FloatFieldUpdateOperationsInput | number
    employerPF?: FloatFieldUpdateOperationsInput | number
    employerESI?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyShiftInput = {
    id?: string
    employeeCode: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    branchId?: string | null
    departmentId?: string | null
    designationId?: string | null
    categoryId?: string | null
    deviceUserId?: string | null
    sourceEmployeeId?: string | null
    dateOfJoining?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    basicSalary?: number
    hra?: number
    conveyance?: number
    medicalAllowance?: number
    specialAllowance?: number
    otherAllowances?: number
    standardDeductions?: number
    bankName?: string | null
    accountNumber?: string | null
    ifscCode?: string | null
    panNumber?: string | null
    aadhaarNumber?: string | null
    isPFEnabled?: boolean
    isESIEnabled?: boolean
    isPTEnabled?: boolean
    isOTEnabled?: boolean
    otRateMultiplier?: number
  }

  export type EmployeeShiftCreateManyShiftInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    designation?: DesignationUpdateOneWithoutEmployeesNestedInput
    category?: CategoryUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    managerApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutManagerNestedInput
    ceoApprovedLeaves?: LeaveEntryUncheckedUpdateManyWithoutCeoNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveEntries?: LeaveEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeShifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfJoining?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basicSalary?: FloatFieldUpdateOperationsInput | number
    hra?: FloatFieldUpdateOperationsInput | number
    conveyance?: FloatFieldUpdateOperationsInput | number
    medicalAllowance?: FloatFieldUpdateOperationsInput | number
    specialAllowance?: FloatFieldUpdateOperationsInput | number
    otherAllowances?: FloatFieldUpdateOperationsInput | number
    standardDeductions?: FloatFieldUpdateOperationsInput | number
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadhaarNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isPFEnabled?: BoolFieldUpdateOperationsInput | boolean
    isESIEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPTEnabled?: BoolFieldUpdateOperationsInput | boolean
    isOTEnabled?: BoolFieldUpdateOperationsInput | boolean
    otRateMultiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type EmployeeShiftUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeeShiftsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryCreateManyLeaveTypeInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    reason?: string | null
    status?: string
    managerApproval?: boolean | null
    managerApprovedAt?: Date | string | null
    managerId?: string | null
    ceoApproval?: boolean | null
    ceoApprovedAt?: Date | string | null
    ceoId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveEntryUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveEntriesNestedInput
    manager?: EmployeeUpdateOneWithoutManagerApprovedLeavesNestedInput
    ceo?: EmployeeUpdateOneWithoutCeoApprovedLeavesNestedInput
  }

  export type LeaveEntryUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveEntryUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    ceoApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ceoApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ceoId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyDeviceInput = {
    id?: string
    deviceUserId: string
    employeeId?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RawDeviceLogCreateManyDeviceInput = {
    id?: string
    userId: string
    punchTime: Date | string
    punchType?: string | null
    isProcessed?: boolean
    createdAt?: Date | string
  }

  export type DeviceUserUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceUserId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RawDeviceLogUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    punchTime?: DateTimeFieldUpdateOperationsInput | Date | string
    punchType?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignationCountOutputTypeDefaultArgs instead
     */
    export type DesignationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftCountOutputTypeDefaultArgs instead
     */
    export type ShiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveTypeCountOutputTypeDefaultArgs instead
     */
    export type LeaveTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceCountOutputTypeDefaultArgs instead
     */
    export type DeviceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesignationDefaultArgs instead
     */
    export type DesignationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesignationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyProfileDefaultArgs instead
     */
    export type CompanyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftDefaultArgs instead
     */
    export type ShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeShiftDefaultArgs instead
     */
    export type EmployeeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HolidayDefaultArgs instead
     */
    export type HolidayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HolidayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveTypeDefaultArgs instead
     */
    export type LeaveTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveEntryDefaultArgs instead
     */
    export type LeaveEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceDefaultArgs instead
     */
    export type DeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceUserDefaultArgs instead
     */
    export type DeviceUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RawDeviceLogDefaultArgs instead
     */
    export type RawDeviceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RawDeviceLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceLogDefaultArgs instead
     */
    export type AttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncStatusDefaultArgs instead
     */
    export type SyncStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollDefaultArgs instead
     */
    export type PayrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}